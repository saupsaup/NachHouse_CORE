{ $DEFINE __NH_WRK } // ak je // budu sa generovat ladiace premenn
{ $DEFINE __NH_WEB }
// { $DEFINE __NH_DALI } // pritomnost DALI
// { $DEFINE __NH_METEO_IQWS_4000 }
// { $DEFINE __NH_FRM }

// NUTNTY ZAKLAD
VAR_GLOBAL CONSTANT
//	_NH2_SYS_DIR 		{HIDDEN}:	STRING[80] := 'W/IMAGES/;W/JS/;W/JSN/;W/LOGS/;W/NOTIFY/;FRM/';				// no-Delete DIRs
	_NH2_VER 			{HIDDEN}:	STRING[3] := 'V21';
	_NH_ZONES {HIDDEN}: USINT			:= 5; // pocet default Zon
   { $ IF CPU_CODE > 1999 }
		_NH_CLUSTER		{HIDDEN}: UDINT			:= 4096;
      _NH_RAM			{HIDDEN}: UDINT			:= 150000;		 // pre 1000 je mensia pamat
      _Nh_WEB_M		{HIDDEN}: USINT			:= 3;					// pocet nezavislych webovych stranok pre M-klientov
      _Nh_USR		 	{HIDDEN}: USINT			:= 5;					// pocet usrov, malo by odpovedat _Nh_WEB_M
// { $DEFINE __NH_FRM } // aktualizuju sa vsetky formulare
   { $ ELSIF CPU_CODE = 1001 OR CPU_CODE = 1047 }
		_NH_CLUSTER		{HIDDEN}: UDINT			:= 512;
// _NH_RAM		{HIDDEN}: UINT			:= 28000;
      _NH_RAM			{HIDDEN}: UDINT			:= 65535;
      _Nh_WEB_M		{HIDDEN}: USINT			:= 1;
      _Nh_USR		 {HIDDEN}: USINT			:= 5;					// pocet usrov, malo by odpovedat _Nh_WEB_M
   { $ ELSE }
		_NH_CLUSTER		{HIDDEN}: UDINT			:= 512;
      _NH_RAM			{HIDDEN}: UDINT			:= 28000;
      _Nh_WEB_M		{HIDDEN}: USINT			:= 1;
      _Nh_USR		 {HIDDEN}: USINT			:= 1;					// pocet usrov, malo by odpovedat _Nh_WEB_M
   { $ END_IF }
// _Nh_ADR_ROT {HIDDEN}: STRING[5] := 'NH2/'; // hlavny adresar konfiguracie
   _Nh_EXP {HIDDEN}: STRING[7] := 'NH2.exp';
	_Nh_CFG			{HIDDEN}: USINT			:= 70;				// pocet viet DEV (kazde DEV ma HED)
	_Nh_PAR			{HIDDEN}: USINT			:= 16;			 	// pocet viet parametrov
	_Nh_VAZ 			{HIDDEN}: USINT			:= 9;			 	// pocet samostatnych sad vazieb aVaz[_Nh_VIO]
//	_Nh_VCF			{HIDDEN}: USINT			:= 2;			 	// pocet viet CFG presortovanycg vazieb na pointroch
//	_Nh_WRK			{HIDDEN}: USINT			:= 3;			 	// pocet viet CFG work pamate, ktora sa vymazava pri kazdom cykle
	_Nh_CAT			{HIDDEN}: USINT			:= 70;				// celkovy pocet kategorii
	_Nh_CAT_STA		{HIDDEN}: USINT			:= 5;				// max pocet stavov kategorii [0..5]
   _Nh_TYP {HIDDEN}: SINT := 5; // MAX pocet zakladnych typov
END_VAR

FUNCTION_BLOCK aTrgQx	{HIDDEN} 				// TRIGER VSTUPU vyhodi zmenu vstupu In, impulz pri zacati a skonceni
	VAR_INPUT
      In: BOOL; // vstup (pre vyhodnotenie zmeny)
   END_VAR
   VAR_OUTPUT
      Qr: 	BOOL; // impulz pri nastaveni vstupu IN - zaroven nastavi aj Q
      Qf: 	BOOL; // impulz pri skonceni vstupu IN - Q uz nie je nastavene
      Qx: 	BOOL;
      Q: 	BOOL; // trvanie signalu na vstupe In
   END_VAR
   Qf := Q AND In = FALSE ;
   Qr := Q = FALSE AND In ;
   Qx := Qf OR Qr;
   Q := In;
END_FUNCTION_BLOCK

TYPE

   NH_DEV_IO		{HIDDEN}: STRUCT
		c: USINT; 				// dev cfg
		n: INT; // cislo DEV
		p: INT; // cislo parametra
   END_STRUCT;

   NH_CFG_ALL {HIDDEN}: STRUCT // rozsirena CFG = vacsina DEV
		Idx: INT;								// index / cislo dev (aCfg[idx])
		typ: SINT; // typ
	 	Rom: USINT; 							// cislo miestnosti
      cat: USINT; // kategoria
		Par: INT; 							// cislo default parametra, 255 znamena, ze sice je parameter, ale pouziva sa az vo vazbach. napr. pri WSB
		Name: STRING[20]; // := 'Všetky miestnosti'; // nazov
      blk: BOOL; // blokovanie DEV
      inv: BOOL; // inverzne DEV (zapnutim sa vypne ON = OFF)
		psn: BOOL; // aktivne dev dava signal pre PSN
// LogEvn: BOOL; // Logovat event = udalost do Log suboru
      LogAct: BOOL; // Logovat akciu od Eventu
      NoShow: BOOL; // nezobrazit v miestnosti v RUN rezime
      DevExt: BOOL; // odkaz na ine DEV (DALI,MQTT..) potom ma .hw strukturu NH_DEV_SW4
//		RestoreLVL: BOOL;	 				 // od 13.3.24 tento par urcuje ci po restarte sa obnovi stav { predtym xDev^.cx.all.LvlOnRst}
//		Dummy1: BOOL;	 				 // od 13.3.24 tento par urcuje ci po restarte sa obnovi stav { predtym xDev^.cx.all.LvlOnRst}
		LvlOnRst: BOOL := TRUE;
		Dummy2: BOOL;
//		ID: STRING[6]; 			 // jednoznacne ID (108_01)
       // ***10.11.22
   	ID: STRING[5]; 			 // jednoznacne ID (108_01)
       // ***30.1.23 do LIP islo aj s tymto, k ROSOCH bez tohto

	END_STRUCT;

	NH_CFG_CFG: STRUCT 					// zakladny konfiguracny subor vsetkych DEV a ich rozlozenie v RAM
		Siz: UDINT;								// 4	velkost jedneho zaznamu
		Ram: UDINT;							 	// 8 	adresa 1.vety vo virtualnej pamati mRam[ vRam ], kde je ulozena xCfg (nulta veta )
      Rec: INT; 	// 10		pocet zaznamov
      ver: USINT := 0; // 11
  		cfg: STRING[3] ;						// 15	 nazov suboru na SDC dev := xxx.***
		New: INT;						 	// 17 pocet novych zaznamov, ktore sa ziadaju
	 	NOk: BOOL; 	// 18
		ini: BOOL;
		ImpExactVer: BOOL := 0;					// obnovuju sa len rovnake verzie
      ImpFullRec: BOOL := FALSE; 			// z DBX sa obnovuje cela veta velkosti SIZ. inak po cf+al+cx...
		ImpFullCfg: BOOL := FALSE;					// z DBX naimportuje vsetky zaznamy k CFG
		DelAfterImp: BOOL := FALSE;					// po importe vsetky zaznamy oznaci ako neplatne - dalsou kontrolou sa odznacia
      ofs: UDINT; // 22	offset Empty premennej od eRom

      par: USINT; // 23 cislo parametra (odkaz do aPar)
      cat: USINT; // 25	cislo cat do ktorej patri toto dev
      ref: USINT := 251; // 26	druh refreshu 251-len to co je na obrazovke,252=to co je na obrazevke a predefinovat,254=novy vypis od 1.zanamu
      tGrp: USINT; // typovy predstavitel/skupina vazieb

      al: USINT;								// 27
      cx: UDINT; // velkost specialnej cfg pre dev
      cf: USINT := SIZEOF(NH_CFG_ALL); // velkost hlavnej cfg
      me: UDINT; // velkost uzivatelskej prevadzkovej pamate
      hw: USINT; // velkost HW pamate
      io: UDINT;

		// potialto sa nesmie prehadzovat

      dummy5: USINT;




		Imp_AL: BOOL;								// vynimka: ma sa obnovovat aj .al napr pre HET}
//		Imp_IO: BOOL;								// .IO sa z DBX neobnovuje

      // dotialto sa obnovuje DBXver > 001
		NbrPoi: USINT;								// priaznak ze ma poi je zaroven aj pocet POI vo vete (ROM=1,HET=2,HEV=2)
      mWsb: USINT; // cislo menu pre akcie od WSB/TLA/TGL
      mnu: USINT; // cislo menu pre ikonu vlastnosti - user _042.MN0
      rExp: USINT; // pocet viet v z exportu
      fBr: USINT; // cislo formatoveho suboru pre pre BRW-ROW, ulozene _Nh_ADR_ROT,'/CFG/FRM/_000.
      fSc: USINT := 200; // cislo menu cez ktore sa dostane so _Nh_Frm_SCR = parametrov DEV
      ar2: BOOL; // '>>' dvojita sipka dalej je v obr[4] prioritou c.1
      lst: BOOL; // ma ikonu DEV-listu {SCN,ACT..}
      stp: BOOL := TRUE; // moze mat odskok na vazby = ikona setup (len v rezime setup)
      fav: BOOL := TRUE; // ma ikonu fav
      chk: BOOL := TRUE; // ma ikonu check (ak je vo vazbach)
      edn: BOOL := TRUE; // moze sa editovat nazov
      sld: BOOL; // DEv ma slider v riadkovom zobrazeni
      ou: BOOL; // tot je vystup - kde sa nieco nastavuje
// dbx: BOOL; // data boli obnovene z DBX
// sdc: BOOL; // data boli obnovene z SDC
// NoDelDBX: BOOL; // pri obnoveni z DBX sa NE-oznaci ako DEL. Potom ju odznaci proces aktualizacie adries z NH2.ADR
      NoRecCat: BOOL; // pri zfiltrovani kategorie sa zobrazia aj ked nemaju ziadny zaznam
// scn: BOOL; // priznak, ze ide o dev, ktore riadi viac vystupnych DEV (SCN,ACT,TIM...) ma nejeky dev-list
      body: BOOL; // tento DEV zapisuje pritomnost

      del: BOOL;			 // je mozne mazat DEV (ON/OFF)
      bck: BOOL := TRUE; // toto cfg sa zalohuje z RAM -> SDC
      imp: BOOL := TRUE; // do cf sa importuju adresy z CIB .... , ROM nebude mat adresy
      NewExp: BOOL; // toto CFG ma z exportu nove data/adresy a musi sa aktualizovat
      QckStat: BOOL; // v HOME-QuickMnu sa vypisuju obrazku zo stat, nie z dev
      lvl254: BOOL; // dev nema max LVL 100% ale 254 = DALI (len pre web)
      analog: BOOL; // dev je 0-100% alebo 0-254 (len pre web)
      dali: BOOL; // patri do dali
      ShwSta: BOOL; 		 // robrazi sa ikona cfg v ROM/ZON ak je niektore z DEV v [cf] aktivne
      zone: BOOL; // moze vstupovat {davat signal} aj do zony (TER,LUX)
		RomIsZone: BOOL;								// xDev^.cf.rom je cislo zony, inak cislo miestnosti {default}
		Visible: BOOL;									// v meu vazieb sa bude zobrazovat visible
		led: BOOL;
		dis: BOOL;
	END_STRUCT;

  	NH_PAR_CFG: STRUCT 					// zakladny konfiguracny subor vsetkych parametrov
		Siz: UDINT;								// 4	velkost jedneho zaznamu
		Ram: UDINT;							 	// 8 	adresa 1.vety vo virtualnej pamati mRam[ vRam ], kde je ulozena xCfg (nulta veta )
      Rec: INT; 	// 10		pocet zaznamov
      ver: USINT := 1; // 11
  		cfg: STRING[3] ;						// 15	 nazov suboru na SDC dev := xxx.***
		New: INT;						 	// 17 pocet novych zaznamov, ktore sa ziadaju
	 NOk: BOOL; 	// 18
		ini: BOOL;
		ImpExactVer: BOOL := FALSE;					// obnovuju sa len rovnake verzie
      ImpFullRec: BOOL := TRUE; 			// z DBX sa obnovuje cela veta velkosti SIZ. inak po cf+al+cx...
		ImpFullCfg: BOOL := FALSE;					// z DBX naimportuje vsetky zaznamy k CFG
		DelAfterImp: BOOL := TRUE;					// po importe vsetky zaznamy oznaci ako neplatne - dalsou kontrolou sa odznacia
      ofs: UDINT; // offset Empty premennej od epSvd
      grp: BOOL; // novy parameter sa vytvori, len ak vstupuje na pozici OUT skupinovych prikazov do SCN,ACT,TIM. Inak sa zoberie default cislo paramtra z DEV
	END_STRUCT;

   NH_REC_VAZ		{HIDDEN}: STRUCT 	// uvodny zaznam pre DEV
 		ok: BOOL;						 // platna veta
   END_STRUCT;
   NH_VAZ		{HIDDEN}: STRUCT 		 // veta vazieb
		ok: NH_REC_VAZ;
		in: NH_DEV_IO; 		// dev in
		ou: NH_DEV_IO; // dev out
	END_STRUCT;

  	NH_VAZ_CFG: STRUCT 			 // zakladny konfiguracny subor vazieb
		Siz: UDINT := SIZEOF(NH_VAZ);		// 4	velkost jedneho zaznamu
		Ram: UDINT;							 	// 8 	adresa 1.vety vo virtualnej pamati mRam[ vRam ], kde je ulozena xCfg (nulta veta )
      Rec: INT; 	// 10		pocet zaznamov
      ver: USINT := 1; // 11
  		cfg: STRING[3] ;						// 15	 nazov suboru na SDC dev := xxx.***
		New: INT;						 	// 17 pocet novych zaznamov, ktore sa ziadaju
	 NOk: BOOL; 	// 18
		ini: BOOL;
		ImpExactVer: BOOL := FALSE;					// obnovuju sa len rovnake verzie
      ImpFullRec: BOOL := TRUE; 			// z DBX sa obnovuje cela veta velkosti SIZ. inak po cf+al+cx...
		ImpFullCfg: BOOL := TRUE;					// z DBX naimportuje vsetky zaznamy k CFG
		DelAfterImp: BOOL := FALSE;					// po importe vsetky zaznamy oznaci ako neplatne - dalsou kontrolou sa odznacia
   END_STRUCT;

  	NH_DBX_VER {HIDDEN}: STRUCT 			// riadiaca hlavicka DBX
      CRC: STRING[12] 	:= '#d13.4!M65y*';
      VER: STRING[3] 	:= _NH2_VER; // .cx a.IO su uz UDINT, pribudl NoRestAl
      Dbx0: UDINT 			:= 0; // pociatocna adresa v DBX ka msa zacina zapisovat aCfg,aPar,aVaz...
	END_STRUCT;
  	NH_DBX: STRUCT 			// riadiaca hlavicka DBX
      ver: NH_DBX_VER ;
		sCfx: ARRAY[0..2] OF USINT := [SIZEOF(NH_CFG_CFG), SIZEOF(NH_PAR_CFG), SIZEOF(NH_VAZ_CFG)];
		nCfx: ARRAY[0..2] OF USINT := [_Nh_CFG, _Nh_PAR, _Nh_VAZ];
		aCfx: ARRAY[0..2] OF UDINT;
      vRam: UDINT; // aktualna velkost dat v aRam[] = posladny zaznam aVaz
		FromDBx128: BOOL := FALSE;				// tento DBX bol obnoveny z databoxu, kde ja max. velkost 128*1024 B
		dummy: STRING[141];
	END_STRUCT;

   NH_DiskInfo: STRUCT 				// HLAVNA RIADIACA PREMENNA
		path		   : STRING[20];
//		delMask		: STRING[10] := '*.DBX,*.';	 // maska suborov na mazanie
		Exist		   : BOOL;						// HW connected
		ErrCrDir		: BOOL;
		GoClean		: BOOL;						// spustit mazanie suborov podla masky
		minSpace		: USINT := 90;			 	// minimalny volny priestor [%]                
		fileDeleted	: UINT;						// pocet vymazanych suborov
		sizeDeleted	: UINT;						// size of all deleted files in KB
		freeSpace	: USINT;                // actual free space in [%]
		Info		   : TDiskInfo;		 		// disk info structure - total/used space in KB
	END_STRUCT;
							

   NH_DISK_HED: STRUCT
		disk: ARRAY[1..4] OF NH_DiskInfo :=
					[	(	path := 'NH2/', minSpace:=95), 			// root
						( 	path := 'USB/', minSpace:=95), // usb
						( 	path := 'SDC/', minSpace:=95), // sdc
						( 	path := 'RAM/', minSpace:=95) // ram
					];
		USB_Ready:   aTrgQx; // := (Qx := FALSE, Q := FALSE, In := TRUE);
		HourClean: 			USINT := 2;					// hour when automaticaly start delete surplus files
		timeExec:    	  	UINT; 						// time create / check all directories
	END_STRUCT;

	NH_LOG_HED_DBX_Write: STRUCT		// datagram
//		FirstDtgrAdr:		UDINT;		// address of the current header	
//		LastDtgrAdr:		UDINT;		// address of the last header written		
		HeadAdr:				UDINT;		// address of the current header
		Rows: 				USINT; 		// current rows in header
 		Bytes: 				INT;  		// current bytes of the entire datagram (header + rows)
		RowAdr:				UDINT;   	// newline address
		buffer:				bool;			// buffer number where writing 1/2
	END_STRUCT;
	NH_LOG_HED_DBX_Read: STRUCT
		buffer:				bool;			// buffer number from reading 1/2. 0=not reading
		DtgrAdr:				UDINT;   	// address of the datagram header to be read
		LastDtgrAdr:		UDINT;		// the address of the datagram header that was written and not read
		LastDtgrLen:		INT:=1200; 	// the length of the datagram with which it was written	
	END_STRUCT;
	NH_LOG_HED_DBX: STRUCT
		write:				NH_LOG_HED_DBX_Write;
		read:					NH_LOG_HED_DBX_Read;				
		HeadLen:				USINT:=12;	// Datagram header length
		DatagramLen:		INT := 1200;	
		DbxBeginAdr: 		UDINT := 0; // zaciatok dat logu
		DbxEndAdr: 			UDINT;
		
		dummy:				STRING[11];
	END_STRUCT;

	NH_LOG_HED: STRUCT
		Quite10Sec: 	USINT;									// kolko sec nebol zapis do evn, podla toho zavrie
		Writes: 			UINT;
     	logDate: 		STRING[8] := '25-04-13';	// log dat
	  	logTime: 		STRING[11] := '13:04:01.12';
		fhEvn: 			HANDLE; // subor textov a prekladov
	END_STRUCT;

(*
	NH_LOG_DBX_HED: STRUCT
		AdrHed: 			UDINT := 0; // adresa hlavicky logu
	END_STRUCT;
*)


   	NH_SYS: STRUCT 				// HLAVNA RIADIACA PREMENNA
		ini						: USINT := 250; 		// Cislo procesu, ktory prebieha. Restart zcina 0... , 255 je vykonavanie finalneho programu
		NewDbx					: BOOL := 0;					// natvrdo sa po restarte vytvaraju vsetky nove dat1
		LogDBx					: NH_LOG_HED_DBX;
		LogHed					: NH_LOG_HED;
		DiskHed					: NH_DISK_HED;
		ADR_DBX					: STRING[25] := 'NH2/200/DBX/25032423/'; // hlavny adresar konfiguracie
		YYYY_MM					: STRING[8] 		:= '2025_01/';

//		IS_USB_DISK: aTrgQx;

		// these variables are one cycle behind the system,
		YEAR			         : USINT;				   // actual YEAR (next cycle after change in  system)
		MONTH			         : USINT;				   // actual MONTH
		DAY			         : USINT;				   // actual DAY
		F_EDGE_1MIN				: BOOL;					// new minute
		F_EDGE_1HOUR			: BOOL;					// 
		F_EDGE_1DAY				: BOOL;					// new day
		F_EDGE_1MON				: BOOL;					// new month
		F_EDGE_1YEAR			: BOOL;					// new Year



		UpdDbx					: USINT;				// sumarny pocet zatial neulozenych modifikacii vo vsetkych suboroch
		UpdFile					: USINT;				// sumarny pocet zatial neulozenych modifikacii vo vsetkych suboroch
		nMemToDbx				: UINT;
		nMemToRBx				: UINT;
		nDbxToMem				: UINT;
		nDbxToFile				: UINT;
		mSec						: UINT;					// pocet miliSec posledneho cyklu - UINT
		mSecMax					: UINT;					// max pocet miliSec za poslednu minutu
		mSecLimit				: UINT := 800;		// obmedzenie dlzky cyklu u suborovych transakcii
		RWtoFileCycle			: UDINT;				// kolko byte bolo zapisane v tomto cykle
		NhDT						: DT;					// na zaciatku cyklu sa nacita DT
		NhDate					: DATE;					// na zaciatku cyklu sa nacita Date
		NhTime					: TIME; 				// na zaciatku cyklu sa nacita

      aRoW1: UDINT; // 1.veta wrk rom
      sRoW: UDINT; // velkost wrk-rom vsetkych viet
      aZoW1: UDINT; // 1.veta prevej zony = domcek
      sZoW: UDINT; // velkost vsetkych wrk-viet ZON
      vIx1: UDINT; // adresa 1.indexu browsu (hned za poslednou vazbou)
      vIx2: UDINT; // adresa posledneho indexu. Je UDINT, lebo moze presiahnut 65 535, potom sa zapisuje do bRam
      Err_vIx2: UDINT; // o kolko prekrocili data browsu limit UINT (65535)
      Err_vDbx: UDINT; // ZAVAZNA CHYBA - o kolko prekrocili hlavne data virtualnu pamat mRam - limit UINT (65535)
      Err_vSrt: UDINT; // ZAVAZNA CHYBA - o kolko prekrocili data vazieb pri sortovani za koniec mRam

		UseRBx: BOOL; 							// namiesto DBx pouzivat RBx
		IS_RBx: BOOL;							// RamBox Exist CPU > 2000
		IS_DBx: BOOL;					 // DataBox Exist

//		CloseAllFiles: BOOL;

//		rst: aTrgQx;
		Size_RBx: UDINT;
		Size_DBx: UDINT;


		OpenFilesCount: UINT;
      LangfH: HANDLE; // subor textov a prekladov

		LuxOut: USINT;
		LuxIn: USINT;
		rSec: REAL;							// pocet miliSec posledneho cyklu - REAL
      rTime: REAL; // aktualny cas v REAL forme



      ErrPt: UINT; // pocet chybnych mapovani xPtr
      ErrPar: UINT; // pocet chybnych mapovani xPtr

//      LastRstDT: DT; // cas posledneho restartu
//      LastRstTyp: USINT; // typ posl.restartu: 1=Cold/hot/restart/none


      ActExp: INT; // aktualne sortovana veta
      SrtExp: INT; // kolkokrat preslo vsetky vety exportu
      RecExp: INT; // pocet viet exportu

      Restart: BOOL; // prebieha restart, v aSys.Ini je to len jeden cyklus
      RestCyc: UINT; 			// pocet sec od restartu, ked bude nastavena RestIni;
		RestartBck: BOOL;							// po uspesnom restarte vytvori po 1.minute ram subor


      Exp: USINT; // stav vytvarania exportu a ADR suboru
// TypExp: USINT; // po restarte 0=nebol export do .ADR, ver.1='RGB_102_01_Q', ver.2='RGB_9A7_Q',
// EndExp: UINT; // adresa poslednej vety docasneho exportu
// IniAdr: USINT; // postupne kroky extrahovania z exportu
// tDbxRam: UINT; // posledny cas cyklu ked boli z DBX obnovene data DO RAM
// tRamDbx: UINT; // posledny cas cyklu ked boli z RAM data zalohovane do RAM

      nDbxRam: UINT; // pocet obnoveni dat z DBX do RAM
      nRamDBX: UINT; // pocet zapisov dat z RAM DO DBX

      dMin: INT; // pocet minut v ramci dna
      n1Sec: USINT; // naplni sa cislom, ked bode sekundovy impulz
      u1Sec: UINT; // to iste co n1Sec len
      u1Min: UINT; // to iste co n1Sec len
      u100mS: UINT; // to iste co n1Sec len
      u50mS: UINT; // to iste co n1Sec len
      i1Sec: INT; // to iste co n1Sec len
      n1Min: USINT; // naplni sa cislom, ked bode MIN impulz
      i1Min: INT; // naplni sa cislom, ked bode MIN impulz
//		NhLcT: UINT; // SYSTEM_S.LAST_CYCLE_TIME_100US; (1s=10 000)
		et50: UINT; 							//
		et100: UINT; 							// napocitava do 1 000	 (100ms )
		et200: UINT; 							// napocitava do 2 000	 (200ms )
		PULSE_50MS: BOOL; // pulz kazdych 50ms
		PULSE_100MS: BOOL; // pulz kazdych 100ms
		PULSE_200MS: BOOL; // pulz kazdych 200ms

		PULSE_BEEP: BOOL; // 0.5s dlhy impulz kazde 2 min
		et_PULSE_BEEP: UINT;
//	 frw: NH_FRW;
      aDbxSdc: UDINT; // pocitocna adresa DBX odkial sa zapisuje
      sDbxSdc: UDINT; // velkost dat DBX pre zapis na SDC_Nh_RAM;
      n100ms: USINT;
      n50ms: USINT;

		Debug: BOOL := TRUE;					// vypisuje debug spravy

		RefCyc: USINT;							// cislo cyklu v sekvencii (0->1->2->3->4) od prechodu na novu minutu ->, alebo iny refresh
		EXP_ROM: BOOL := TRUE; // preberat z exportu aj miestnosti ak sa najdu
		RefCycNew: BOOL;							// poziadavka na rucne nastartovanie sekvencie
      chg: BOOL; // priznak modifikacie parametrov od posledneho ulozenia
      Qf230: BOOL; // impulz pri vypadku napatia
      Qr230: BOOL; // impulz pri obnoveni napatia
      QfHDO: BOOL; // impulz pri vypnuti HDO
      QrHDO: BOOL; // impulz pri zapnuti HDO
      prgChange: BOOL;
      CfgRamOk: BOOL; // v RAM sa nachadzaju platne data (z DBX, SDC alebo novovytvorene). Mozu byt aktualnejsie ako v DBX
      CfgDbxOk: BOOL; // true = v dbx je CFG ok ,
		CfgBckOk: BOOL; // posledne zistovanie, ci existuje subor na SDC podla dbx.mem
      ExtPSN: BOOL; // stav komunikacie s Ext PSN
      Locked: BOOL; //
      Open: BOOL; //
      pass: BOOL;
// CPU_DO0: BOOL; // rele 0 na CPU, ktore sa pouziva na HW-reboot procesora
      DO0_REBOOT: BOOL; // rele 0 na CPU, ktore sa pouziva na HW-reboot procesora
      Sim: BOOL; // simulator PLC
		cyc: BOOL;
	END_STRUCT;





   NH_BTN8 {HIDDEN}: ARRAY[1.. 8] OF BOOL;
	NH_BTN3 {HIDDEN}: ARRAY[1.. 3] OF BOOL;
   NH_BTN4 {HIDDEN}: ARRAY[0.. 3] OF BOOL;
   NH_BTN05 {HIDDEN}: ARRAY[0.. 5] OF BOOL;
   NH_BTN15 {HIDDEN}: ARRAY[0..15] OF BOOL;
   NH_LVL15 {HIDDEN}: ARRAY[0..15] OF USINT;
   NH_PV03 {HIDDEN}: ARRAY[0.. 3] OF USINT;
   NH_PV18 {HIDDEN}: ARRAY[1..8] OF USINT; // click 1-5, P,H [switch,0,0,0,0,Push,Hold,0]

   NH_PV01 {HIDDEN}: ARRAY[0.. 1] OF USINT;
   NH_PI14 {HIDDEN}: ARRAY[1..14] OF INT;

	NH_IO_BUSY : STRUCT 	// unviversal output struct Done...ErrID.. actSize...cyc
		Go :			USINT;				// Case
//		what :		USINT;				// universal variable
     	exec : 		BOOL:=TRUE; 		// start (auxiliary init variable)
     	busy : 		BOOL:=TRUE; 		// in progress
     	done : 		BOOL; 				// all done (busy=FALSE)
     	found : 		BOOL; 				// partially done (busy=TRUE)
		init :		BOOL;					// new start
		err : 		BOOL;					// any error
		errTyp : 	SINT:=-1; 			// -1=NoEntry, 0=sys,1=NachHouse,2=NschHouse+sys
		errID : 		UDINT;				// if empty, then err.errID := GetLastErr();
		seek :		UDINT;				// starts from position / addres / universal 
     	reqSize :	UDINT; 				// required size
     	actSize :	UDINT; 				// really written actually
		cycSize : 	UDINT; 		 		// actualy R/W Size per cycle ONLY
		cyc :			UINT;					// how many cycles takes procedure

  //    mode : 		TF_MODE; 			// 0=F_READ,1=F_WRITE,2=F_APPEND {ak je seek=0 => append na koniec, seek>0..zapise na pozociu seek}
	END_STRUCT


END_TYPE

VAR_GLOBAL CONSTANT
   _Cfg0 {HIDDEN}: UDINT := SIZEOF(NH_DBX); 	// zaciatok CFG
   _Par0 {HIDDEN}: UDINT := _Cfg0 + SIZEOF(NH_CFG_CFG) * _Nh_CFG; // zaciatok PAR
   _Vaz0 {HIDDEN}: UDINT := _Par0 + SIZEOF(NH_PAR_CFG) * _Nh_PAR; // zaciatok VAZ
   _Ram0 {HIDDEN}: UDINT := _Vaz0 + SIZEOF(NH_VAZ_CFG) * _Nh_VAZ; // prva veta aCfg[1] rom = 1.miestnost

   DayNamesSVK: ARRAY [1..7] OF STRING [2] := [ 'Po', 'Ut', 'St', 'Št', 'Pi', 'So', 'Ne'];
   _NhDLtask 	{HIDDEN}:	USINT := 64; // max. pocet uloh pre jeden DALI-master
	_NH_CRLF		{HIDDEN}: 	STRING[2]		:= '$r$n';
   _eBtn3 		{HIDDEN}:	NH_Btn3;
   _1Btn3 		{HIDDEN}:	NH_Btn3 := [1, 1, 1];
   _eBtn8 		{HIDDEN}:	NH_Btn8;
   _1Btn8 		{HIDDEN}:	NH_Btn8 := [1, 1, 1, 1, 1, 1, 1, 1];
   _eBtn05 		{HIDDEN}:	NH_Btn05;
   _1Btn05 		{HIDDEN}: 	NH_BTN05 := [1, 1, 1, 1, 1, 1];
   _eBtn15 		{HIDDEN}: 	NH_Btn15;
   _1Btn15 		{HIDDEN}: 	NH_Btn15 := [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
	_eLvl15		{HIDDEN}:	NH_LVL15;
	_eIOBusy		{HIDDEN}: 	NH_IO_BUSY;

END_VAR

VAR_GLOBAL // grobalne pouzivane premenne
	mRam					 	{HIDDEN}: ARRAY[0.._NH_RAM] OF BYTE; // mapovanie virtualnej ram (VR)
   mObr 	{HIDDEN}: ARRAY[1..4096] OF BYTE;
	Base0 AT mObr[3069] {HIDDEN}: UDINT ;						// before yTx6
	yTxa 	AT mObr[3073] {HIDDEN}: STRING[255] ;						// before yTx6
	yTxb 	AT mObr[3329] {HIDDEN}: STRING[255] ;						// before yTx6
	yTxc 	AT mObr[3585] {HIDDEN}: STRING[255] ;						// before yTx6
	yTx0 	AT mObr[3841] {HIDDEN}: STRING[255] ;						// before yTx6


	yTx1 	{HIDDEN}: STRING[255] ;
	yTx2 	{HIDDEN}: STRING[255] ;
	yTx3 	{HIDDEN}: STRING[255] ;
   yTx4 	{HIDDEN}: STRING[255] ;
	eTxt 	{HIDDEN}: STRING[0] ;

	xTx1 	{HIDDEN}: PTR_TO STRING[255] ;
	xTx2 	{HIDDEN}: PTR_TO STRING[255] ;

   aSys: NH_SYS;
   aDbx AT mRam: NH_DBX;

(*
   { $ IF CPU_CODE > 1999 }
      CPU_DI {HIDDEN} AT r16_p6_IO_IN.DIS;
      CPU_DO {HIDDEN} AT r16_p6_IO_OUT.DOS;
   { $ ELSIF CPU_CODE = 1004 } 	 // 1000,1001,1047
      CPU_DI {HIDDEN} AT r0_p3_DI;
      CPU_DO {HIDDEN} AT r0_p3_DO;
   { $ ELSE } 	 // 1000,1001,1047
      CPU_DI {HIDDEN} AT r0_p5_DI;
      CPU_DO {HIDDEN} AT r0_p5_DO;
   { $ END_IF }
 *)
END_VAR

(*
VAR_GLOBAL CONSTANT
   DayNamesSVK: ARRAY [1..7] OF STRING [2] := [ 'Po', 'Ut', 'St', 'Št', 'Pi', 'So', 'Ne'];
   _NhDLtask 	{HIDDEN}: USINT := 64; // max. pocet uloh pre jeden DALI-master
	_NH_CRLF				{HIDDEN}: STRING[2]		:= '$r$n';
   _eBtn3 	{HIDDEN}: NH_Btn3;
   _1Btn3 	{HIDDEN}: NH_Btn3 := [1, 1, 1];
   _eBtn8 	{HIDDEN}: NH_Btn8;
   _1Btn8 	{HIDDEN}: NH_Btn8 := [1, 1, 1, 1, 1, 1, 1, 1];
   _eBtn05 	{HIDDEN}: NH_Btn05;
   _1Btn05 	{HIDDEN}: NH_BTN05 := [1, 1, 1, 1, 1, 1];
   _eBtn15 	{HIDDEN}: NH_Btn15;
   _1Btn15 	{HIDDEN}: NH_Btn15 := [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
	_eLvl15				{HIDDEN}: NH_LVL15;
END_VAR
*)


TYPE
	NH_ARR_OUT {HIDDEN}: ARRAY[0..3] OF USINT := [ 0 , 25 , 50 , 100 ];
  	NH_ARR_VAL {HIDDEN}: ARRAY[0..3] OF REAL := [ 5.0, 20.0, 23.0, 25.0];
   NH_RGB_LVL {HIDDEN}: STRUCT
      lvl: ARRAY[1..5] OF USINT := [255, 255, 255, 0, 0]; // parametre pre 3.kanaly R/G/B/WC/WA
   END_STRUCT;

	NH_RFID {HIDDEN}: ARRAY[0..7] OF BYTE; // kompletny RFID kod aj 13Mhz

   NH_CFG_CLICK	{HIDDEN}: STRUCT
		Click: USINT := 6;					 // max cas medzi clickmi [x 100ms]. Ak je = 0, vyhodnoti sa len prvy click
		Press: USINT := 7; 				 // cas po ktorom je uz stlacenie [x 100ms]
		Hold: USINT := 0; 			 // cas po ktorom je dlhe podrzanie [x 100ms]
      LockTime: USINT := 10; // ak je stlaceny btn viac ako 10s vypne sa posielanie CMD, je to zaseknuty BTN
		nBTNs: USINT := 2;	 // celkovy pocet btn
      BtnHold: ARRAY[1..8] OF BOOL; // ktore BTN pouzivaju hold {vylucuje sa s press} rezervovane aj pre klavesnicu
      OneClck: ARRAY[1..8] OF BOOL; // ktore BTN maju len JEDEN-rychly click
	END_STRUCT;

  	NH_BTN_CLICK	 {HIDDEN}: STRUCT
		cmd: USINT;
      Nbr: USINT; // cislo aktualne stlaceneh BTN v HW
      Click: USINT; // cislo clicku
      wht: USINT; // stavy
		Lck: USINT;								// zaseknute TLACIDLO/TGL
		shw: USINT;								// oneskorenie zobrazenia
		et: UINT;
		Busy: BOOL;
      Lock: BOOL; // zaseknuty BTN, treba reset TGL
	END_STRUCT;

   NH_VAL_3 {HIDDEN}: STRUCT
      val: ARRAY[0..3] OF REAL := [5.0, 18.5, 21.5, 23.5]; // hodnoty predvolieb
	END_STRUCT;
   NH_DEV_HW0	{HIDDEN}: STRUCT
		typ: USINT;
		cfg: USINT;
		d: ARRAY[0..0] OF UDINT; // adresy Dev
	END_STRUCT;
   NH_DEV_HW1	{HIDDEN}: STRUCT
		typ: USINT;
		cfg: USINT;
		d: ARRAY[0..1] OF UDINT; // adresy Dev
	END_STRUCT;
   NH_DEV_HW2 {HIDDEN}: STRUCT
		typ: USINT;
		cfg: USINT;
		d: ARRAY[0..2] OF UDINT; // adresy Dev
	END_STRUCT;
   NH_DEV_HW3	{HIDDEN}: STRUCT
		typ: USINT;
		cfg: USINT;
		d: ARRAY[0..3] OF UDINT; // adresy Dev
	END_STRUCT;
   NH_DEV_HW4	{HIDDEN}: STRUCT
		typ: USINT;
		cfg: USINT;
		d: ARRAY[0..4] OF UDINT; // adresy Dev
	END_STRUCT;
   NH_DEV_HW5	{HIDDEN}: STRUCT
		typ: USINT;
		cfg: USINT;
		d: ARRAY[0..5] OF UDINT; // adresy Dev
	END_STRUCT;
   NH_DEV_EXT	{HIDDEN}: STRUCT
		typ: USINT;
		cfg: USINT := 1; // 0=CIB,1=DALI,2=MQTT
		d: ARRAY[0..5] OF UDINT; // adresy Dev
	END_STRUCT;
  	NH_TRIG {HIDDEN}: STRUCT 			 // DEL oD oQ fav >> o5 o6 o7 o8 o9 o10 DEL
      In: BOOL ;				// vstupny signal
  		Q: BOOL ;				// preneseny vstup (minuly stav)
      Qf: BOOL ; // zostupna hrana
      Qr: BOOL ; // nabezna hrana
	END_STRUCT;
   NH_CLK_CMD {HIDDEN}: STRUCT 			// Co sa vykona pri konkretnom clicku / push / hold , click+push
// cmd: ARRAY[1..8] OF USINT := [2,0,0,0,0,6,6,0]; // click 1-5, P,H [switch,0,0,0,0,Push,Hold,0]
		cmd: NH_PV18;	// := [0,0,0,0,0,6,6,0]; // click 1-5, P,H [switch,0,0,0,0,Push,Hold,0]
	END_STRUCT;

(*
  	NH_FRW {HIDDEN}: STRUCT 					 // prenosovy subor citania/zapisu
      fH: HANDLE; // otvoreny subor
      fP: UDINT; // aktualna poziacia v fH
      fN: STRING[50]; // subor pre _Nhfrw
      fR: UDINT; // kolko bolo posledne nacitane/zapisane
      fA: UDINT; // kolko bolo doteraz celkovo nacitane x
// mode: TF_MODE; // 0=read,1=write,2=append
	END_STRUCT;
 *)

   NH_DT_M {HIDDEN}: STRUCT // struktura NH datumu+casu
    	year: USINT; (* rok (poslední dvì èíslice letopoètu) *)
    	month: USINT; (* mìsíc (1 .. 12) *)
    	day: USINT; (* den (1 .. 28/29/30/31) *)
    	hour: USINT; (* hodina (0 .. 23) *)
    	min: USINT; (* minuta (0 .. 59) *)
//		sec: usint; (* sekunda (0 .. 59) *)
  	END_STRUCT;

   NH_REC_OK	 {HIDDEN}: STRUCT 	// uvodny zaznam pre DEV
 		ok: BOOL;						 // platna veta
      ref: BOOL; // treba prepocitat/aktualizovat data DEV
      stp: BOOL; // zobrazi sa len v SETUP mode
      adm: BOOL; // ma pristup len ADMIN (CAT)
		cpy: BOOL;								// oznacenie pree kopirovanie
      CmdInBlk: BOOL; // vstup je blokovany = neprijima data, dokial ich FB nespracuje
      CmdOuRpt: BOOL; // treba opakovat zaslaty CMD, vystupne DEV bolo zaneprazdnene
		DevRef: BOOL;								// zmena nejakeho parametra - refresh samotneho dev
   END_STRUCT;


  	NH_CMD_ALL {HIDDEN}: STRUCT 		//
		cmd: USINT; 							// command
		val: REAL; 	 // hodnota, ktora prislucha k CMD (napr.teplota,sumrak...)
		par: INT; 	// parameter, pod ktorym sa ma vykonat CMD (0=pouzije sa default par)
	END_STRUCT;

   NH_DEV_CF		{HIDDEN}: STRUCT
		c: USINT; 			 // dev cfg
		n: INT; // cislo DEV
   END_STRUCT;

   NH_DEV_SW		{HIDDEN}: STRUCT
		c: USINT; 			 // dev cfg
		n: INT; // cislo DEV
		o: USINT;								// vystupny/vstupny port (pri DALI R/G/B/WW/CW )
   END_STRUCT;

  	NH_VAL_IO {HIDDEN}: STRUCT 				// prenos vstupnej veliciny
      own: BOOL;								// ma vlastny snimac (u TER/LUX je to v default ROM)
   	Zon: BOOL;								// pre LUX v rom/zon: hodnota bola prebrata z nadradenej zony
		Out: BOOL; // pre LUX v rom/zone: z vonkajsej zony
	 chg: BOOL; 								// zmena - po prenesni n CMD sa vynuluje
		cmd: BOOL;								// chg sa preniesla na cmd a ten by sa mal vyslat
//		FromOwn: BOOL := 1;						// prebrat hodnotu z vlastnej miestnosti ak existuje
		FromZon: BOOL := 1;						// povolenie prebrat hodnotu z vyssej zony, ak sa nenasla FromOwn - v 1.poradi
		FromOut: BOOL := 1;						// povolenie prebrat hodnotu z vonkajsej zony - v 2.poradi
      val: REAL; // posledna hodnota
		dev: NH_DEV_SW;
   END_STRUCT;



  	NH_DEV_ALL {HIDDEN}: STRUCT 	// default pre vsetky DEV - MAXIMALNA konfiguracia
		in: NH_CMD_ALL; 					// vstupny prikaz
		ou: NH_CMD_ALL; 					// vystupy prikaz
      sta: USINT; // stav, podla ktoreho za vykresli obrazok s podkladom
		cm: USINT;
   	et: UINT;
      Qf: BOOL; // impulz, ked skoncil cas: et
	 trg: NH_TRIG;
      wsb: BOOL; // priznak, ze cmd prisiel z ovladaca WSB alebo WEB
      vaz: BOOL; // ma nejake in-vazby WSB,PIR,TGL...
      lst: BOOL; // bit8 je nejakom DEV-liste SCN,ACT,....
      up: BOOL := TRUE; // bit1 smer stmievania up=hore (po restarte zacina nadol)

      Qx: BOOL; // univerzalne pouzitie - impulz, ked sa dosiahne ukoncenie casu do 0
      dummyEvn: BOOL; // logovat udalost
      Off: BOOL; // priroritne je priznak dlheho vypnutia, inak univerzalne,

      RUN: USINT; // co sa vykona po dobehnuti casu
      ct: USINT; //
      ex: INT; // bezi pomocny cas - vacsinou kontroluje maximalnu dobu zopnutia
      rmp: USINT; // rampa
      el: USINT; // dalsi pomocny cas - zisti sa dlhe vypnutie
// lvl: USINT; // zapamatana uroven
// par: INT; // zapamatany parameter
	END_STRUCT;

  	NH_DEV_ALL_M {HIDDEN}: STRUCT 	// default pre vsetky DEV - MAXIMALNA konfiguracia
		in: NH_CMD_ALL; 					// vstupny prikaz
		ou: NH_CMD_ALL; 					// vystupy prikaz
      sta: USINT; // stav, podla ktoreho za vykresli obrazok s podkladom
		cm: USINT;
   	et: UINT;
      Qf: BOOL; // impulz, ked skoncil cas: et
	 trg: NH_TRIG;
      wsb: BOOL; // priznak, ze cmd prisiel z ovladaca WSB alebo WEB
      vaz: BOOL; // ma nejake in-vazby WSB,PIR,TGL...
      lst: BOOL; // je nejakom DEV-liste SCN,ACT,....
      up: BOOL := TRUE; // smer stmievania up=hore (po restarte zacina nadol)
	END_STRUCT;

  	NH_POI_DAT {HIDDEN}: STRUCT // struktura pre slider z viacerych casovych pointov - uchovava sa
      t: INT := - 1; // casova znacka (pocet minut dna)
      o: SINT; // co je v tejto casovej znacke (hodnota/odkaz )
	END_STRUCT;
   NH_POI_OBR {HIDDEN}: STRUCT
      o: INT; // obrazky k hodnotam
      c: USINT; // color
	END_STRUCT;
  	NH_ARR_POI {HIDDEN}: STRUCT // struktura pre slider z viacerych casovych pointov - uchovava sa
      p: ARRAY[0..7] OF NH_POI_DAT;
	END_STRUCT;
   NH_POI_FIX	{HIDDEN}: STRUCT // kedy vratit na bezny kalendarny den 6 byte
		dummy: BOOL;
      wht: USINT; // sposob kedy 1 = okamzite
      tme: NH_DT_M; // datum/cas
	END_STRUCT;
   NH_POI_DAY	{HIDDEN}: STRUCT // casovy program kurenia jedneho dna
		fff: BOOL;
      Day: USINT; // vybraty den 0=Week, 1-7=(PO-NE),8=,Free,9=Full,10=Out,11=Holi/vynimka)
      Poi: ARRAY[1..11] OF INT;
// Fix: NH_POI_FIX := (wht:=1); // zablokuje, aby sa Day kazdu min aktualizoval z Home
	END_STRUCT;

   NH_POI {HIDDEN}: STRUCT // casovy program kurenia jedneho dna
 		ok: NH_REC_OK := (ok := 1);
      cx: NH_ARR_POI :=
                  ( p := [ ( t := 0, o := 2), // night 0:00
                           ( t := 330, o := 3), // morning 5:30
                           ( t := 390, o := 0), // day 6:30
                           ( t := 1050, o := 1), // evening 17:30
                           ( t := 1440, o := 1) // 24:0;
                   ]);
	END_STRUCT;
  	NH_ARR_OBR {HIDDEN}: STRUCT 		// obrazky pre interval v NH_ARR_POI
      o: ARRAY[0..4] OF NH_POI_OBR
                                          := [ ( o := 140, c := 5), // day
                                                ( o := 142, c := 3), // evening
                                                ( o := 144, c := 9), // night
                                                ( o := 146, c := 8) // morning
                                                ];
	END_STRUCT;
  	NH_POD_CFG {HIDDEN}: STRUCT // riadiaca struktura pre TIM-slider z viacerych casovych pointov - uchovava sa
      tim: BOOL := TRUE; // vypisanie casu, aj vynasacej ciary
      typ: USINT; // 0=Daymode,1=Heat,2=Ven
      n: SINT := 7; // maximalny pocet pointov = bodov ZADAVA sa
      o: SINT := 3; // pocet hodnot/obrazkov vyberanych do jednotlivych pointov ZADAVA sa
      vo: NH_ARR_OBR;
      va: NH_ARR_VAL;
      fm: STRING[8] := ''; // format hodnoty (ak jeprazdne, nevypisuje sa)
	END_STRUCT;


   NH_ROM_LCK {HIDDEN}: STRUCT
      KeyCode: BOOL; // prisiel dobry kod z Klavesnice
      WebCode: BOOL; // prislo z webu
		LockRom: BOOL := 1;			 		 // tato miestnost/zona bude zamykana
		AllLocked: BOOL ;			 		 		 // vsetky miestnosti su zalokovane
		FromZone: BOOL := 0;			 		 // ZON prepise udaje v ROM, ROM=povoli prepisat
		ChangeStat: BOOL;							 // impulz pri zmene stavu PSN
		AllLockedOld: BOOL ;			 		 		 // minuly stav zalokovania vsetkych miestnosti
     	Stat: USINT := 0; // 0=unlock, 1=locking, 2=locked, 3=unlocking, 4=dog, 5=Narusenie, 6=Alarm
      et: UINT ; // prebieha nejaky cas podla Lock
      tdOu: UINT := 10;	// 60; // odchodove oneskorenie [SEC]
      tdIn: UINT := 13;	// 30; // prichodove oneskorenie [SEC]
      tDog: UINT := 16;	// 60; // ostrazitost [sec]
      tNar: UINT := 30;	// 300; // Cas narusenie
      tRst: UINT := 0;	// 300; // Cas autoresetu bez pohybu v LVL - ALARM
		StatOld: USINT;
		dummy: STRING[9];
   END_STRUCT;

  	NH_CFX_ROM_LUX {HIDDEN}: STRUCT
		LuxMin: USINT := 70;						// minimalna hodnota osvetlenia
		RolMin: USINT := 80;						// minimalna hodnota zatienenia zaluziami
		KoefBli: REAL := 0.0; // cim viac poklasne osvetleni pod 100%, pouzije sa este neviem ako ake koef
		LuxYes: BOOL := 1;							// ovplyvneny snimacom
		RolYes: BOOL := 1;							// ovplyvneny snimacom
   END_STRUCT;

  	NH_CFX_ROM {HIDDEN}: STRUCT 			// CFX MIESTNOSTI
		LuxMin_OLD: USINT;								// len pre kompatibilitu - minimalna hodnota osvetlenia
      NoBody: UINT := 1800; // pocet SEC, bez pritomnosti (Auto-nepritomnost) = vyhlasi sa klud
      BlPirOFF: USINT := 1; // cas [min] blokovania PIR po vypnuti vypinacom/z webu 255=do konca dna
      pRzv_OLD: USINT; // odkial zobrat rodicovsky rozvrh: 0-Nema Rodica, 1(255)-Domcek, > 1=konkretna zona
      pDay: NH_POI_DAY; // DayMode
      lck: NH_ROM_LCK;						// uz aj lock je + string[10]
      FixDay: NH_POI_FIX := (wht := 1); // zablokuje, aby sa Day kazdu min aktualizoval z Home

		// nove
		LuxPar: NH_CFX_ROM_LUX;
      Dark: BOOL; // tma - musi tu byt, lebo porestarte ak je nastavene rucne by sa stratilo
		IniDefault: BOOL;								// priznak inicializacie
      dummy: STRING[19];


// Fix: NH_POI_FIX := (wht:=1); // zablokuje, aby sa Day kazdu min aktualizoval z Home

   END_STRUCT;

(* posledne
  	NH_CFX_ROM {HIDDEN}: STRUCT 			// CFX MIESTNOSTI
		LuxMin: USINT;								// minimalna hodnota osvetlenia
      NoBody: UINT := 1800; // pocet SEC, bez pritomnosti (Auto-nepritomnost) = vyhlasi sa klud
      BlPirOFF: USINT := 1; // cas [min] blokovania PIR po vypnuti vypinacom/z webu 255=do konca dna

      pRzv: USINT; // odkial zobrat rodicovsky rozvrh: 0-Nema Rodica, 1(255)-Domcek, > 1=konkretna zona
      pDay: NH_POI_DAY; // DayMode
      lck: NH_ROM_LCK;

      dummy: STRING[19];
   END_STRUCT;
 *)

   NH_ROM_MEM {HIDDEN}: STRUCT
		Locked: BOOL;								// jednoznacne povie ze je zamknute
      BodyQr: BOOL; // nova pritomnost - impulz
      BodyQ: BOOL; // pritomnost trva
      PsnQr: BOOL; // nova pritomnost - impulz
      PsnQ: BOOL; // pritomnost trva
		Light: NH_TRIG;							// zapnutie/vypnutie/trvanie osvetlenia
      DayObr: SINT; // obrazok denneho modo 0,1,2,3 day,evening,night/morning
      BlPirOn: USINT := 253; 	// po restarte blokuje pir 254 cyklov
      BlPirOff: USINT; // bezi cas blokovanie PIR-ov v miestnosti po vypnuti WSB/WEB
		DarkRolLvl: USINT; 	 // uroven zatienenia roletami
//		refStat: USINT;								// LOCK status z minuleho cyklu


// tNoBody: UINT; // pocet minut zostavajucich do vyhlasenia nepritomnosti
// tLock: UINT; // cas pre odchod,prichod,strazenie,koniec alarmu vbez pohybu
// tAlarm: UINT; // pocet minut do prepnutia na vyssi level ALARMU
//		cm: USINT;								// pomocna prem. pre alarm
//		sta: USINT;

	END_STRUCT;

   NH_ROM		{HIDDEN}: STRUCT
 		ok: NH_REC_OK := (ok := TRUE);
      cf: NH_CFG_ALL := (typ := 1);
	 al: NH_DEV_ALL;
//	 al: NH_ROM_ALL;
      cx: NH_CFX_ROM;
		io: ARRAY[100..104] OF NH_VAL_IO; // TER,LUX,CO2,RH
      me: NH_ROM_MEM;
	END_STRUCT;

  	NH_ZON_PAR 	{HIDDEN}: STRUCT 			// PARAMETRE MIESTNOSTI
 		ok: NH_REC_OK;
		cmd: USINT := 60;
	END_STRUCT;

  	NH_DEV_OKA {HIDDEN}: STRUCT 	// default pre vsetky DEV - MAXIMALNA konfiguracia
		ok: NH_REC_OK;
		cf: NH_CFG_ALL;
		al: NH_DEV_ALL;
	END_STRUCT

END_TYPE

VAR_GLOBAL
	rb {HIDDEN}: BOOL;
//   err {HIDDEN}: BOOL;
//   exec {HIDDEN}: BOOL;
   ok {HIDDEN}: BOOL;
   ok1 {HIDDEN}: BOOL;						 // casto pouzivana premenna
   ok2 {HIDDEN}: BOOL;
   ok3 {HIDDEN}: BOOL;
   ok4 {HIDDEN}: BOOL;
   rst {HIDDEN}: BOOL;						 // casto pouzivana premenna
   rom {HIDDEN}: BOOL;
   sbj {HIDDEN}: BOOL;
   yes {HIDDEN}: BOOL;

	// zdielane pre pracu s SDC
	fH {HIDDEN}: HANDLE;			// handle
   fP {HIDDEN}: UDINT; // file Position
   fS {HIDDEN}: UDINT;	 		// file Size
   fRW 	{HIDDEN}: UDINT;				// file Rear/write	- pocet byte na zapis/citanioe

   sp	 {HIDDEN}: UDINT;
   sz {HIDDEN}: UDINT;
   sPtr {HIDDEN}: UDINT;
   sRun {HIDDEN}: UDINT;
	offSrc			{HIDDEN}: UDINT;		// posun pri kopirovani
	offDst			{HIDDEN}: UDINT;

   xBtn15 	{HIDDEN}: PTR_TO NH_Btn15;		// koli memCpyPtr
   yBtn15 	{HIDDEN}: NH_Btn15;		// koli memCpyPtr


   i {HIDDEN}: USINT;
   k {HIDDEN}: USINT;
   ii {HIDDEN}: USINT;
   cf {HIDDEN}: USINT;
   vo {HIDDEN}: USINT;
   vi {HIDDEN}: USINT;
   rmp {HIDDEN}: USINT; // rapa pre SVA,RGB
   cmd {HIDDEN}: USINT; // rapa pre SVA,RGB
// GoNext {HIDDEN}: USINT;

   j {HIDDEN}: SINT; // rapa pre SVA,RGB
   jj {HIDDEN}: SINT;

   x {HIDDEN}: INT;
   y {HIDDEN}: INT;
   z {HIDDEN}: INT;
   ix {HIDDEN}: INT;
   qx {HIDDEN}: INT;
   qy {HIDDEN}: INT;
// v1,v2,v3 {HIDDEN}: INT;
   nd {HIDDEN}: INT; // vseobecne cislo zanzmau
   nDel {HIDDEN}: INT; // cislo vymazaneho zaznamu
   nNew {HIDDEN}: INT; // cislo vymazaneho zaznamu
   new {HIDDEN}: INT;
   grp {HIDDEN}: INT;
   del {HIDDEN}: INT; // univerzalne

	rj				 {HIDDEN}: UDINT;
	rji			 {HIDDEN}: UINT;
   va {HIDDEN}: UDINT; // virtualna adresa
   vai {HIDDEN}: UINT; // virtualna adresa
   delay {HIDDEN}: UINT;
	_NhSeed			{HIDDEN}: DINT;
	_NhDT				{HIDDEN}: DT;
	_NhTime			{HIDDEN}: TIME;

   kr {HIDDEN}: REAL;
   vr {HIDDEN}: REAL; // REAL pre pouzitie do slidera
   ur {HIDDEN}: REAL;

   xx {HIDDEN}: REAL;
   yy {HIDDEN}: REAL;
   zz {HIDDEN}: REAL;
   aa {HIDDEN}: REAL;
   bb {HIDDEN}: REAL;
   cc {HIDDEN}: REAL;
   ee {HIDDEN}: UDINT;
	ff	{HIDDEN}: UDINT;

   xPtB {HIDDEN}: PTR_TO BOOL;
	xPtS			{HIDDEN}: PTR_TO SINT;
	xPtU			{HIDDEN}: PTR_TO USINT;
   xPtU2			{HIDDEN}: PTR_TO USINT;
	xPtR			{HIDDEN}: PTR_TO REAL;
	xMin			{HIDDEN}: PTR_TO REAL;
	xMax			{HIDDEN}: PTR_TO REAL;
	xPtI			{HIDDEN}: PTR_TO INT;
	xPtUi			{HIDDEN}: PTR_TO UINT;
	xPtT			{HIDDEN}: PTR_TO TIME;
	xPtY			{HIDDEN}: PTR_TO BYTE;
	xPtD			{HIDDEN}: PTR_TO UDINT;
	xPtC			{HIDDEN}: PTR_TO STRING;
	xPtIO			{HIDDEN}: PTR_TO NH_VAL_IO;
	xPtIOa		{HIDDEN}: PTR_TO NH_VAL_IO;
//	yPtIO			{HIDDEN}: NH_VAL_IO;

   xLedR {HIDDEN}: PTR_TO BOOL;
	xLedG {HIDDEN}: PTR_TO BOOL;
	xLedB {HIDDEN}: PTR_TO BOOL;
   xLedO {HIDDEN}: PTR_TO BOOL;
   xBeep {HIDDEN}: PTR_TO BOOL;

  	xCPa {HIDDEN}: PTR_TO NH_PAR_CFG;
   xCIo {HIDDEN}: PTR_TO NH_VAZ_CFG;
	xDbx	 {HIDDEN}: PTR_TO NH_DBX; // hlavny riadiaci subor vratane organizacie DBX
	yDbx	 {HIDDEN}: NH_DBX; // hlavny riadiaci subor vratane organizacie DBX
   yCfg {HIDDEN}: NH_CFG_CFG; // konfiguracia vsetkych DEV

	fbDbxFromFile: ReadDbxFromFile;
   fbDbxToFile: WriteDbxToFile;
	_LangTXT 	{HIDDEN}: STRING[30];
	xDevOkA		{HIDDEN}: PTR_TO NH_DEV_OKA;
END_VAR

FUNCTION _Nh_Get_PathName {HIDDEN}: BOOL	// edit fN : extract pathName  or fileName from fN and return save to fN 
	VAR_INPUT
		file : 	BOOL; 		
	END_VAR
	VAR_IN_OUT
		fN :	 	STRING;
	END_VAR
	VAR_TEMP
		p :	INT;
      s :   STRING[1];
	END_VAR
	_Nh_Get_PathName := TRUE;
	p := LEN(fN);
	WHILE p > 1 DO
		IF file THEN
			fN := MID(fN,p-1,2);			
			IF FIND(fN,'/') = 0 THEN	
				EXIT;		
			END_IF;	
		ELSE
         s:= MID(fN,1,p);
         IF s = '/' THEN	
   			EXIT;		
         END_IF;
		END_IF;				
		p := p - 1; 
	END_WHILE;
END_FUNCTION

FUNCTION {HIDDEN} _Nh_N12: UINT // podla podmienky vrati o1, alebo o2
   VAR_INPUT
      in: BOOL;
      o1: UINT;
      o2: UINT;
   END_VAR
   IF in THEN _Nh_N12 := o1;
   ELSE _Nh_N12 := o2;
   END_IF;
END_FUNCTION

FUNCTION {HIDDEN} _Nh_O12: INT // podla podmienky vrati o1, alebo o2
   VAR_INPUT
      in: BOOL;
      o1: INT;
      o2: INT;
   END_VAR
   IF in THEN 	_Nh_O12 := o1;
   ELSE 			_Nh_O12 := o2;
   END_IF;
END_FUNCTION

FUNCTION {HIDDEN} _Nh_U12: USINT // podla podmienky vrati o1, alebo o2
   VAR_INPUT
      in: BOOL;
      o1: USINT;
      o2: USINT;
   END_VAR
   IF in THEN 	_Nh_U12 := o1;
   ELSE 			_Nh_U12 := o2;
   END_IF;
END_FUNCTION

FUNCTION {HIDDEN} _Nh_S12: SINT // podla podmienky vrati o1, alebo o2
   VAR_INPUT
      in: BOOL;
      o1: SINT;
      o2: SINT;
   END_VAR
   IF in THEN 	_Nh_S12 := o1;
   ELSE 			_Nh_S12 := o2;
   END_IF;
END_FUNCTION

FUNCTION {HIDDEN} _Nh_D12: UDINT // podla podmienky vrati o1, alebo o2
   VAR_INPUT
      in: BOOL;
      o1: UDINT;
      o2: UDINT;
   END_VAR
   IF in THEN 	_Nh_D12 := o1;
   ELSE 			_Nh_D12 := o2;
   END_IF;
END_FUNCTION


FUNCTION _NheRam {HIDDEN}: BOOL // VYNULUJE PREVADZKOVU RAM (za DBX,CFG,PAR,VAZ)
   memsetEx(val := 0, length := _NH_RAM - aDbx.vRam, dest := VOID( mRam[aDbx.vRam ] ) );
END_FUNCTION

FUNCTION _NhMemSetPTR {HIDDEN}: BOOL 	// vymaze mRam od Adresy pointra v dlke size
   VAR_INPUT
      size: UDINT; 	// velkost vymazanej pamate
      dest: PTR_TO USINT; 	// pointer na zaciatok pamate
      mAdr: UDINT;
   END_VAR
	_NhMemSetPTR := TRUE;
   IF mAdr = 0 THEN
      mAdr := PTR_TO_UDINT(dest) - PTR_TO_UDINT(ADR(mRam)) ;
   END_IF;
	memsetEx(val := 0, length := size, dest := VOID( mRam[ mAdr ])) ; // vycisti celu ram !! DOLEZITE
END_FUNCTION

FUNCTION _NhMemClrPTR {HIDDEN}: BOOL // vymaze pamat od Adresy pointra v dlke size
   VAR_INPUT
      size: UDINT; // velkost vymazanej pamate
      dest: PTR_TO USINT; // pointer na zaciatok pamate
   END_VAR
	_NhMemClrPTR	:= TRUE;
   memset(val := 0, length := 1020, dest := VOID(yTx1)); 
   WHILE size > 0 DO
      MemcpyPtr(source := ADR(yTx1), dest := dest, length := MIN(size, 1020)); // prekopiruje cistu pamat na adresu
      dest := dest + MIN(size, 1020);
      size := size - MIN(size, 1020);
   END_WHILE;
END_FUNCTION

FUNCTION _NhClrRam {HIDDEN}: BOOL // vymazanie v adresovanej pamati mRam podla pointru
   VAR_INPUT
      a: PTR_TO USINT; // adresa pointru
      s: UINT; // velkost dat, ktore sa prepisu 0
   END_VAR
   VAR_TEMP
      d: UDINT;
   END_VAR
   d := PTR_TO_UDINT(a) - PTR_TO_UDINT( ADR(mRam) );
   memset(val := 0, length := s , dest := VOID( mRam[ d ] ) );
   _NhClrRam := TRUE;
END_FUNCTION


FUNCTION {HIDDEN} aBlank: BOOL	// append string with spaces to length n
	VAR_INPUT
   	lft: 	BOOL; 					// zlava medzery
      txt: 	PTR_TO STRING[255];
		n: 	USINT;
   END_VAR
   VAR_TEMP
		p: 	USINT;
   END_VAR
  	p := LEN(txt^);
   IF lft THEN
      WHILE n > 0 DO // doplnit medzerami
         txt^ := INSERT(txt^, ' ', 1);
         n := n - 1;
   	END_WHILE;
   ELSIF p >= n THEN // string > ako sa pozaduje
	 	txt^ := LEFT(txt^, p);
   ELSE
   	WHILE p < n DO // doplnit medzerami
         txt^ := CONCAT(txt^, ' ');
         p := p + 1;
   	END_WHILE;
   END_IF;
   aBlank := TRUE;
END_FUNCTION

FUNCTION_BLOCK aTrg	{HIDDEN} 				// TRIGER VSTUPU vyhodi zmenu vstupu In, impulz pri zacati a skonceni
	VAR_INPUT
      In: BOOL; // vstup (pre vyhodnotenie zmeny)
      rst: BOOL; //
   END_VAR
   VAR_OUTPUT
      Qr: BOOL; // impulz pri nastaveni vstupu IN - zaroven nastavi aj Q
      Qf: BOOL; // impulz pri skonceni vstupu IN - Q uz nie je nastavene
      Q: BOOL; // trvanie signalu na vstupe In
      Qe: BOOL; // impulz, ked sa et dopocita k 0
      et: UINT; // po

   END_VAR
   Qe := FALSE;
   IF rst THEN
      rst := FALSE;
// In := true; // pri resete sa zavola aj in
      Q := FALSE;
      et := 0;
      Qr := FALSE;
      Qf := FALSE;
      RETURN;
   END_IF;
   Qr := In AND Q = FALSE;
   Qf := In = FALSE AND Q;
   Q := In;
   IF et = 0 THEN
      ;
   ELSIF et > aSys.mSec THEN
      et := et - aSys.mSec;
   ELSE
      et := 0;
      Qe := TRUE;
   END_IF;
END_FUNCTION_BLOCK

FUNCTION aTrim {HIDDEN}: BOOL								// vyhodi pociatocne a kocove medzery
	VAR_INPUT
      wht: USINT; // 0=zLava, 1=zlava aj zprava, 2=zlava, vsetky medzery
      txt: PTR_TO STRING; // pointer premennej
   END_VAR
   VAR_TEMP
      n: INT;
      zn: STRING[1];
   END_VAR
   aTrim := TRUE;
   n := LEN(txt^);
   WHILE n > 0 DO
      CASE wht OF
         0: // zprava
            zn := MID(txt^, 1, n);
            IF zn = ' ' THEN
               n := n - 1;
               txt^ := LEFT(txt^, n);
            ELSE
               EXIT;
            END_IF;
         1: // zpava aj zlava
            zn := MID(txt^, 1, n);
            IF zn = ' ' THEN
               n := n - 1;
               txt^ := LEFT(txt^, n);
            ELSE
               zn := MID(txt^, 1, 1);
               IF zn = ' ' THEN
                  n := n - 1;
                  txt^ := MID(txt^, n, 2);
               ELSE
                  EXIT;
               END_IF;
            END_IF;
         2: // zlava
            zn := MID(txt^, 1, 1);
            IF zn = ' ' THEN
               n := n - 1;
               txt^ := MID(txt^, n, 2);
            ELSE
               EXIT;
            END_IF;
       ELSE // vsetky medzery v stringu
            n := FIND(in1 := txt^, in2 := ' ');
            IF n > 0 THEN
               txt^ := DELETE(txt^, 1, n);
            ELSE
               EXIT;
            END_IF;
      END_CASE;
   END_WHILE;
END_FUNCTION

FUNCTION _Nh_Sys_Log_Path: BOOL 	// SysLog path: WWW/NH2/NH2_YYMM.log; ADR "RRMM.log' OR ".log
	VAR_INPUT
//		del:		BOOL; 			// delete old log file at start
		ram:		BOOL; 			// use RAM disk
		rrmm:		BOOL:=TRUE; 	// use rrmm in file name
//		wh:		USINT; 			// use whole path from aSys.DiskHed.disk[2].path
	END_VAR
	VAR_IN_OUT
		Path:		STRING;
	END_VAR
	_Nh_Sys_Log_Path	:= TRUE;
	IF ram AND aSys.DiskHed.Disk[4].Exist THEN
		Path := aSys.DiskHed.Disk[4].Path;
	ELSE
//		path	:=	CONCAT(aSys.DiskHed.Disk[2].path,'LOG/');
//		path	:=	aSys.DiskHed.Disk[4].path;
		path	:=	'WWW/NH2/NH2_';
	END_IF;
(*
	CASE wh OF
		0: Path := CONCAT(path,'NH2_');
		1: Path := CONCAT(path,'DEL_');
	END_CASE;
*)	
//	Path := CONCAT(path,'NH2_');
//	Path := CONCAT(path,'NH2_');
	IF rrmm THEN
		Path := CONCAT(path, DT_TO_STRINGF(aSys.NhDT, '%TYYMM.log') );
	ELSE
		Path := CONCAT(path, '.log') ;
	END_IF;
END_FUNCTION

FUNCTION _NhSysLogMsg: BOOL // nacita 1.riadok zo suboru yTx1 do yTx2, alebo zapise to co je v yTx2 do suboru yTx1
   VAR_INPUT
		write: 		BOOL; 			// overwrite file
		noIni:		BOOL; 			// no Write position for aSys.ini
		noTime:		BOOL; 			// nezapisovat cas
		noLog:		BOOL; 			// nezapisovat log
		noCRLF:		BOOL;				// no add CRLF at the End
		debug:		BOOL;				// only if aSys.debug = TRUE
		eRowBefore:	BOOL;				// prida prazdny riadok pred a za
		eRowAfter:	BOOL;				// prida prazdny riadok pred a za
		spcLeft:		BOOL;				// Only IF lenMsg>0; TRUE:=add spaces from the Left to the length lenMsg; FLSE:=from the Right
		lenMsg:		USINT; 			// length of message	
		msg:	 		STRING[255]; 	// message to log without datetime
		maxSize:		UINT:=1000;		// maxSize [kB]	
		openfH:		HANDLE;	// := INVALID_HANDLE_VALUE;		
	END_VAR
	VAR_TEMP
		fH: 			HANDLE;
		logFile: 	STRING;
	END_VAR
	_NhSysLogMsg	:= FALSE;
	IF noLog OR (debug AND aSys.Debug = FALSE) THEN					// log only in debug mode
		RETURN;
	ELSE
		IF openfH <> INVALID_HANDLE_VALUE THEN 						// uz otvoreny subor, kde s bude zapisovat na nastavene miesto
			fH	:= openfH;
		ELSE
			rb:=_Nh_Sys_Log_Path(Path:=logFile);
		   IF write THEN
   		   fH := FileOpen(fileName := logFile, mode := F_WRITE);
		   ELSE
   		   fH := FileOpen(fileName := logFile, mode := F_APPEND);
	   	END_IF;
		END_IF;
   	IF fH <> INVALID_HANDLE_VALUE THEN 	// nenajdeny subor alebo zla cesta
			IF maxSize =0 OR FileSize(hFile := fH) < UINT_TO_UDINT(maxSize*100) THEN						// obmedzenie logu na 0.5mb
				IF NoTime THEN
					logFile	:= '';	
	         ELSE	
					logFile := DT_TO_STRINGF(GetRtc(), '%TYY.MM.DD-hh:mm:ss.zzz ');
				END_IF;
				IF noIni = FALSE THEN
		        	logFile := CONCAT(logFile, USINT_TO_STRINGF(aSys.ini, '[%3u:] '));
				END_IF
  		   	msg := CONCAT(logFile,msg) ;
				IF noCRLF THEN ;
				ELSIF FIND(msg,_NH_CRLF) = 0 THEN
      		   msg := CONCAT(msg, _NH_CRLF );
				END_IF;	
		      IF eRowBefore THEN
   		      msg := CONCAT(_NH_CRLF, msg);
      		END_IF;
		      IF eRowAfter THEN
   		      msg := CONCAT(msg,_NH_CRLF);
      		END_IF;
				If lenMsg > 0 THEN
					aBlank(	lft := spcLeft, txt := ADR(msg), n := lenMsg );
				END_IF;
				fRW	:= FileWrite(hFile := fH, adrBuf := PTR_TO_UDINT(ADR(msg)), size := INT_TO_UDINT(LEN(msg)));
				_NhSysLogMsg:= fRW = INT_TO_UDINT(LEN(msg)) ;
			END_IF;
			IF openfH = INVALID_HANDLE_VALUE THEN 		
				rb	:= FileClose(hFile := fH);
			END_IF;
		END_IF;	
	END_IF;
END_FUNCTION

FUNCTION _Nh1RowTxt: BOOL // nacita 1.riadok zo suboru yTx1 do yTx2, alebo zapise to co je v yTx2 do suboru yTx1
   VAR_INPUT
      write: BOOL; // zapisat
      append: BOOL := TRUE; // pridat, prioritne je write
      close: BOOL := TRUE; // close file on end
      logRst: BOOL;
// sysIni: BOOL := true; 	 // prida aSys.ini ak je LogRst
      EmpRow: BOOL; // pred riadok prida '$r$n' = prazdny riadok
		adHed1: BOOL;							// pridat prvy riadok to je v yTx3
      adTime: SINT; // za datum pridat aj cas
   END_VAR
// VAR_TEMP
// fH: HANDLE;
//		begin: UDINT;
// END_VAR
   IF logRst THEN
// yTx1 := CONCAT( _Nh_ADR_ROT,'NH2.LOG');
// yTx1 := CONCAT( aSys.ADR_RAM,'NH2.LOG');
// yTx1 := 'RAM/NH2.LOG';
//		yTx1	:= CONCAT('WWW/NH2/NH_', DT_TO_STRINGF(aSys.NhDT, '%TYYMM.log') );
//		yTx1	:= CONCAT(aSys.DiskHed.disk[2].path, 'nh_', DT_TO_STRINGF(aSys.NhDT, '%TYYMM.log') );
//		yTx1	:= CONCAT( 'WWW/LOGS/NH2_', DT_TO_STRINGF(aSys.NhDT, '%TYYMM.LOG') );
// yTx1 := 'WWW/LOGS/NH2.LOG';
// 	yTx1 := '/SDC/NH2.LOG';
// yTx1 := CONCAT( aSys.ADR_DBX,'NH2.LOG');
		rb:=_Nh_Sys_Log_Path(Path:=yTx1);
   END_IF;
   fRW := 0;
   IF write THEN
      fH := FileOpen(fileName := yTx1, mode := F_WRITE);
   ELSIF append THEN
      fH := FileOpen(fileName := yTx1, mode := F_APPEND);
   ELSE
		_Nh1RowTxt	:= FALSE;
  		RETURN;
   END_IF;
   IF fH <> INVALID_HANDLE_VALUE THEN 	// nenajdeny subor alebo zla cesta
		IF logRst THEN
			IF FileSize(hFile := fH) > 500000 THEN						// obmedzenie logu na 0.5mb
   			rb				:= FileClose(hFile := fH);
				_Nh1RowTxt := FALSE;
 				RETURN;
			END_IF;
		END_IF;
		offSrc	:= 1;										// start position first character in original yTx2
		CASE adTime OF
		 - 1: ;
			0: IF logRst THEN
         	yTx2 := CONCAT(DT_TO_STRINGF(GetRtc(), '%TYY.MM.DD-hh:mm:ss.zzz '), USINT_TO_STRINGF(aSys.ini, '[%3u:] '), yTx2 ); offSrc := 22;
(*
       			yTx2 := CONCAT(
//			 			UDINT_TO_STRINGF( TIME_TO_UDINT( SUB_DT_DT(aSys.NhDT,aSys.LastRstDT))/100 ,'%6.3d'),' '
			 			TIME_TO_STRINGF( SUB_DT_DT(aSys.NhDT, aSys.LastRstDT) , '%Tss.zzz'), ' '
						, UINT_TO_STRINGF(aSys.RestCyc, '%3u ')
						, USINT_TO_STRINGF(aSys.ini, '[%3u:] ')
						, yTx2
								);
					offSrc := 17;		//	move first character of yTx2 fo this position
*)
				END_IF;
    		1: yTx2 := CONCAT(DT_TO_STRINGF(aSys.NhDT, '%Thh:mm '), yTx2);						offSrc := 7;
         2: yTx2 := CONCAT(DT_TO_STRINGF(aSys.NhDT, '%Thh:mm:ss '), yTx2); offSrc := 10;
         3: yTx2 := CONCAT(DT_TO_STRINGF(GetRtc(), '%TYY.MM.DD-hh:mm:ss.zzz '), yTx2); offSrc := 22;
//         3: yTx2 := CONCAT(DT_TO_STRINGF(aSys.NhDT, '%TYY.MM.DD-hh:mm:ss.zzz '), yTx2); offSrc := 22;
         4: yTx2 := CONCAT(DT_TO_STRINGF(aSys.NhDT, '%TYY.MM.DD-hh:mm:ss.zz '), _NH_CRLF, yTx2, _NH_CRLF); offSrc := 24;
         ELSE yTx2 := CONCAT(DT_TO_STRINGF(getRTC(), '%Thh:mm:ss.zz '), yTx2); 		offSrc := 13;
      END_CASE;
      fRW := FIND(yTx2, _NH_CRLF);
      IF fRW = 0 THEN
         yTx2 := CONCAT(yTx2, _NH_CRLF);
      END_IF;
		IF adHed1 THEN													// ak je subor prazdny, prida hlavicku
			IF FileSize(hFile := fH) = 0 THEN
		 		fRW := FIND(yTx3, _NH_CRLF);
   		 	IF fRW = 0 THEN
      			 yTx3 := CONCAT(yTx3, _NH_CRLF);
	 			END_IF;
         	yTx2 := CONCAT(yTx3, yTx2);
				offSrc := offSrc + LEN(yTx3) + 2;
			END_IF;
		END_IF;
      IF EmpRow THEN
         yTx2 := CONCAT(_NH_CRLF, yTx2);
      END_IF;
      fRW := FileWrite(hFile := fH, adrBuf := PTR_TO_UDINT(ADR(yTx2)), size := INT_TO_UDINT(LEN(yTx2)));

// yTx2 := LEFT(yTx2,fRW-2); 		// odstrani CRLF z konca
      yTx2 := MID(yTx2, fRW - 2, OffSrc); // odstrani CRLF z konca a nacita od povodneho zaciatku

		aSys.RWtoFileCycle := aSys.RWtoFileCycle + fRW;
		IF close THEN
		 	rb		:= FileClose(hFile := fH);
		END_IF;
   END_IF;
   _Nh1RowTxt := fRW > 0;
END_FUNCTION



FUNCTION _NhGetTimeCyc {HIDDEN}: TIME			// returns actual time cycle
	_NhGetTimeCyc := SUB_DT_DT(GetRtc(), aSys.NhDT);
END_FUNCTION
FUNCTION _NhMaxTimeCyc {HIDDEN}: BOOL			// returns if the cycle time up to this moment is greater than the specified value
	VAR_INPUT
		tc: UDINT := 300; // := CPU_MAX_CYCLE_TIME-CPU_MAX_CYCLE_TIME/8;
	END_VAR
	_NhMaxTimeCyc := TIME_TO_UDINT(_NhGetTimeCyc()) >= tc;	// T#0.3s THEN
END_FUNCTION
FUNCTION _NhMaxRWLimit {HIDDEN}: BOOL			// returns if the cycle time up to this moment is greater than the specified value
	VAR_INPUT
		rw: UDINT := _NH_CLUSTER * 5;
	END_VAR
	_NhMaxRWLimit	:= aSys.RWtoFileCycle > rw;
END_FUNCTION

FUNCTION _NhFclose {HIDDEN}: BOOL // otvori/zavrie subor
	VAR_INPUT
		dir: 	BOOL;
	END_VAR
   VAR_IN_OUT
      fh: 	HANDLE;
   END_VAR
   _NhFclose := TRUE;
   IF fh <> INVALID_HANDLE_VALUE THEN // otvorit
		IF dir THEN
	 		_NhFclose := DirClose (hDir := fH);
		ELSE
      	fS := FileSize(hFile := fH); // do GLB sa vlozi velkost suboru
	 		_NhFclose := FileClose(hFile := fH);
		END_IF;
   	IF _NhFclose THEN
			fh := INVALID_HANDLE_VALUE;
		END_IF;
	END_IF;
END_FUNCTION

FUNCTION _NhTF_MODE_S : STRING[1] 	// retun string enum TF_MODE
   VAR_INPUT
      mode: 	TF_MODE; // 0:=F_READ {default} 1:=F_WRITE, 2:=F_APPEND, 3:= F_READ_PLUS
	END_VAR
	IF mode = 0 	THEN _NhTF_MODE_S := '0';		// F_READ otevrít soubor pro ctení
	ELSIF mode = 1 THEN _NhTF_MODE_S := '1';		// F_WRITE otevrít soubor pro zápis, zápis dat bude od zacátku souboru
	ELSIF mode = 2 THEN _NhTF_MODE_S := '2';   	// F_APPEND otevrít soubor pro zápis,data budou pripojena na konec souboru
	ELSIF mode = 3 THEN _NhTF_MODE_S := '3';    // F_READ_PLUS otevrít soubor pro ctení i pro zápis
	ELSE	              _NhTF_MODE_S := '?';
	END_IF;
END_FUNCTION

FUNCTION _NhFopen {HIDDEN}: BOOL // otvori subor, do fS zapise velkost a do fP nastaveny offset
   VAR_INPUT
      close: 	BOOL := TRUE; // ak je na zaciatku otvorene, najskor zavrie
      EndCl: 	BOOL; // na konci zavrie (..pre vytvorenie suboru, alebo test... )
		log: 		BOOL := TRUE;
      seek: 	UDINT; // data offset in file
      mode: 	TF_MODE; // 0:=F_READ {default} 1:=F_WRITE, 2:=F_APPEND, 3:= F_READ_PLUS
	END_VAR
   VAR_IN_OUT
      fH: 		HANDLE;
      fN: 		STRING;
   END_VAR
   _NhFopen := FALSE;
   IF close AND fh <> INVALID_HANDLE_VALUE THEN
      rb := _NhFclose(fH := fH);
   END_IF;
   fH	:=	FileOpen(fileName := fN, mode := mode);
	fS	:= 0;
   IF fh <> INVALID_HANDLE_VALUE THEN
      fS := FileSize(hFile := fH); // do GLB sa vlozi velkost suboru
      fP := 0; // poziacia v subore
      IF fS=UNKNOWN_SIZE THEN
         EndCl := TRUE; // ak je neznama velkost, uzavrie subor a vrati false
			rb:=_NhSysLogMsg(msg:='! _NhFopen fS=UNKNOWN_SIZE; fN: {'+fN+'};mode:'+_NhTF_MODE_S(mode)+';fS='+UDINT_TO_STRING(fS),debug:=true); // mode:'+mode);
      ELSE
         _NhFopen := TRUE;
      END_IF;
      IF EndCl THEN // na konci zavrie
         _NhFopen := FALSE;
      ELSIF mode = 1 THEN // ked je F_WRITE, offset {seek} sa ignoruje, zapisuje sa od zaciatku
         ;
      ELSIF _NhFopen AND seek > 0 THEN // je otvoreny a ma sa presunut na poziciu {offset}
         // ako funguje offset {seek}:
         // F_WRITE vynuluje subor a nastavi fS:=0
         // F_APPEND otvori a zapise velkost do fS
         // potom obidva mody: ak seek>fS doplnia pre poziciu 'seek' znaky 'NULL' a od pozicie 'seek' zapisu data
         // preto treba seek obmedzit na velkost fS, aby sa neazpisovali 'NULL';
         IF seek <= fS THEN // ziadana pozicia <= ako velkost suboru
            IF FileSetPos( hFile := fh, offset := seek) THEN	//
               fP := seek;
            ELSE
               _NhFopen := FALSE;
               fP := 0;
            END_IF;
         ELSIF mode = 2 THEN // pri append je pozicia nastavena na koniec suboru
            fP := fS;
         ELSE
            _NhFopen := FALSE; // F_READ, F_READ_PLUS nenaslo poziciu, vrati false
		 		rb:=_NhSysLogMsg(msg:='! _NhFopen seek <= fS: fN:{'+fN+'};mode:'+_NhTF_MODE_S(mode)+';fS='+UDINT_TO_STRING(fS),debug:=true); // mode:'+mode);
         END_IF;
      END_IF;
      IF _NhFopen = FALSE THEN // na konci zavrie
//         _NhFopen := _NhFclose(fH := fH);
      	rb := _NhFclose(fH := fH);
      END_IF;
	ELSIF log THEN	
		rb	:=	GetLastErrTxt(errCode := GetLastErr(), errMessage := yTx0);
		rb	:=	_NhSysLogMsg(msg:='! _NhFopen Err: "'+yTx0+'";fN:{'+fN+'};mode:'+_NhTF_MODE_S(mode),debug:=true); // mode:'+mode);
   END_IF;
END_FUNCTION

FUNCTION _NhFdelete {HIDDEN}: BOOL // deletes the file if it exists, first closes it if it is open - without errors
	VAR_INPUT
		open: 	BOOL; 		// at the end open
      mode: 	TF_MODE; 	// 0:=F_READ {default} 1:=F_WRITE, 2:=F_APPEND, 3:= F_READ_PLUS
	END_VAR
   VAR_IN_OUT
      fN: 		STRING;
		fH: 		HANDLE;
   END_VAR
	_NhFdelete := _NhFclose(fH := fH);										// first close if open - withouth Err 
   IF _NhFdelete THEN 												
		IF FileExists( fileName := fN) THEN		 	
			_NhFdelete := FileDelete( fileName := fN );					// first close if open - withouth Err 
		END_IF;
	END_IF;
	IF _NhFdelete AND open THEN
		_NhFdelete := _NhFopen( fH:=fH, fN:=fN, mode:=mode, close:=FALSE );		
	END_IF;
END_FUNCTION

FUNCTION _NhFread {HIDDEN}: BOOL
   VAR_INPUT
		adrVar:	PTR_TO UDINT; 
		fS:		UDINT;	
	END_VAR
   VAR_IN_OUT
      fH: 		HANDLE;
      fN: 		STRING;
   END_VAR
	fRW:=0;
 	IF _NhFOpen(fN:=fN, fH:=fH, close:=FALSE, mode:=0 ) THEN
  		fRW 	:= FileRead  (hFile := fH, adrBuf := PTR_TO_UDINT(adrVar), size := fS );
		rb		:= _NhFClose(fH:=fH);
	END_IF;
	_NhFread := fRW = fS;
END_FUNCTION

FUNCTION _NhFwrite {HIDDEN}: BOOL
   VAR_INPUT
		adrVar:	PTR_TO UDINT; 
		fS:		UDINT;	
      mode: 	TF_MODE := F_WRITE;
	END_VAR
   VAR_IN_OUT
      fH: 		HANDLE;
      fN: 		STRING;
   END_VAR
	fRW:=0;
 	IF _NhFOpen(fN:=fN, fH:=fH, mode:=mode ) THEN
  		fRW 	:= FileWrite  (hFile := fH, adrBuf := PTR_TO_UDINT(adrVar), size := fS );
		rb		:= _NhFClose(fH:=fH);
	END_IF;
	_NhFwrite := fRW = fS;
END_FUNCTION

FUNCTION _Nh_Line_RW: BOOL // write a fixed length line+CRLF or read a specific line
	// yTx1 .. log file name {full path}
	// yTx2 .. content to write into log file
	// !!! GLOBAL VAR fP will be owerwriten and return the position of the next line !!!
   VAR_INPUT
      mode:       TF_MODE;       // 0=F_READ,1=F_WRITE,2=F_APPEND
		LineNbr:    UDINT := 1;	   // number of Line for read/write
      LineLen:    UDINT := 40;   // length line (included CRLF := 2)
		read255:    BOOL;          // cumulative function: reopens the file, reads the first 255 where it looks for a LineNbr terminated by CRLF, close file
		readFP:     UDINT;			// read from File Position
		close:      BOOL := TRUE;  // close at the end
      new:        BOOL;          // delete file and create new
		fExist:     BOOL;			   // test if the loaded file actually exists
   END_VAR
   VAR_IN_OUT
      fH:         HANDLE; // file handle
   END_VAR
   _Nh_Line_RW := FALSE;
	IF read255	THEN
		rb := _NhFclose(fH := fH);
		fH := INVALID_HANDLE_VALUE; LineLen := 0; close := TRUE; // readFP := 0;
	ELSIF new THEN
      rb := _NhFclose(fH := fH); // close file for delete
		rb 	:= FileDelete(fileName := yTx1);
   END_IF;
   IF fH <> INVALID_HANDLE_VALUE THEN ;
   ELSIF _NhFopen(fN := yTx1, fH := fH , mode := mode) THEN ;
	ELSIF fExist THEN
//		rb := _NhSysLogMsg(msg:='File NOT Exists: {' + yTx1 + '}',ini:=FALSE);
		RETURN;
	ELSE
		RETURN;
   END_IF;
   IF mode = F_READ THEN
		IF LineLen = 0 THEN														// look for CRLF
			rb 	:= FileSetPos( hFile := fH, offset := readFP);
		 	fRW 	:= FileRead (hFile := fH, adrBuf := PTR_TO_UDINT(ADR(yTx2)), size := 255); // try to read the whole line
			aSys.RWtoFileCycle := aSys.RWtoFileCycle + fRW / 4;
			new	:= TRUE;
			fP		:= readFP + fRW;
         WHILE fRW > 0 DO // AND LineNbr > 0 DO 		// 1	 4 6
// 	 	 LineLen := INT_TO_UDINT(FIND(yTx2,_NH_CRLF)); 		// 'aaaCRbbbbbCRddddd'
    	 	LineLen := FIND(yTx2, _NH_CRLF); 		// 'aaaCRbbbbbCRddddd'
	 		IF LineLen > 0 THEN 	// 4 6
					IF new THEN
						new 	:= FALSE;
						fP		:= readFP + LineLEn + 2;						// save start position of the next Line
    				END_IF;
					LineNbr := LineNbr - 1;
					IF LineNbr > 0 THEN										 	//	 4 6
    					yTx2 	:= DELETE(in := yTx2, L := LineLen + 1, P := 1); // 'aaaCRbbbbbCRddddd' -> 'bbbbbCRddddd'
			 ELSE
//						LineLen	:= LineLen - 1;
     					yTx2 		:= LEFT(yTx2, LineLen - 1); // We found the requested line.
						fRW		:= 0;
					END_IF;
    			ELSE																	// 'dddd'
					EXIT;																// force another to read data from file
            END_IF;
      	END_WHILE;
			LineLen := 0; 						// _NhLineRW := LineNbr = LineLen;
			IF LineNbr > 0 THEN
//				rb 	:= _Nh_Lang(id:=1001 ,txt := ADR(yTx2),wht:=1);
//				yTx2	:=	CONCAT(yTx2,': ',UDINT_TO_STRING(LineNbr)); // File from Line NOT Exist
			ELSIF fExist THEN
				IF FileExists( fileName := yTx2) = FALSE THEN		 	// test file
					yTx2	:= CONCAT('File NOT Exists: ', '{', yTx2 , '}');
//					_Nh_Lang(id:=1001 ,txt := ADR(yTx2),wht:=1);
//					yTx2:=CONCAT(yTx2,': ',UDINT_TO_STRING(LineNbr)); // File from Line NOT Exist
					LineLen := 999; 		// not found
				END_IF;
			END_IF;
		ELSE
			yTx2		:= '';
			IF readFP = 0	THEN
				readFP 	:= ( (LineNbr - 1) * LineLen );
			END_IF;
			rb 		:= FileSetPos( hFile := fh, offset := readFP); // vzdy je true, ak je otvoreny subor
   		LineNbr 	:= FileRead (hFile := fH, adrBuf := PTR_TO_UDINT(ADR(yTx2)), size := LineLen );
			fP			:= readFP + LineNbr;
		END_IF;
   ELSE
      // 123456789 12
      // 12345*....CF
      IF LineLen = 0 THEN
         LineLen := LEN(yTx2) + 2; // neriadi sa fixnou dlzkou, ale prida len dlzku strigu + NUL + CRLF {'12345NULCRLF'}
      END_IF;
		memsetEx(val := 16#20202020, length := LineLen - LEN(yTx2) - 1, dest := VOID(yTx2), offDest := LEN(yTx2) + 1); // vymaze string medzerami
      memsetEx(val := 16#0a0d, length := 2, dest := VOID(yTx2), OffDest := LineLen - 2); // + CRLF
      IF mode = F_WRITE THEN
			LineNbr 	:= ( (LineNbr - 1) * LineLen );
    	ELSIF mode = F_APPEND THEN
			;
    	ELSE
         { $ IF CPU_CODE > 1999 }
// lineNbr := 16#FFFF_FFFF;
            lineNbr := END_POS;
         { $ ELSE }

            lineNbr := 16#FFFF;
         { $ END_IF }
			readFP	:= LineNbr;
   	 rb 		:= FileSetPos( hFile := fh, offset := readFP);
	 END_IF;

		LineNbr 	:= FileWrite(hFile := fH, adrBuf := PTR_TO_UDINT(ADR(yTx2)), size := LineLen);
		fP			:= readFP + LineNbr;
		aSys.RWtoFileCycle := aSys.RWtoFileCycle + LineNbr;
   END_IF;
   _Nh_Line_RW := LineNbr = LineLen; // to co sa chcelo sa zapisalo
   IF close THEN
      rb := _NhFclose(fH := fH);
   END_IF;
END_FUNCTION

FUNCTION _Nh_Log_PATH: BOOL 	// all paths for files, rename, copy, log
	VAR_INPUT
		month:	BOOL;
		read: 	BOOL;
		write: 	BOOL;
		DD_hh: 	BOOL; // create day+time file	: DD_hhmm to yTx1
		DD_hhmm:	BOOL; // create day+time file	: DD_hhmm to yTx2
		suffix:	BOOL; // add suffix to file		".fN"
		restart: BOOL;
   	wh	: 		USINT;
		wh2: 		USINT; // additional parameter
	  	frm: 		UINT;
		obr:		UINT;	
		fN	: 		STRING[3]; 	// file name or suffix
   END_VAR
	VAR_TEMP
		txt: 		STRING[10];
	END_VAR
	_Nh_Log_PATH	:= TRUE;
	yTx1			:= fN; STRING_TO_LOWER(yTx1);
	CASE wh OF
		0:	RETURN;

      2:	// LOG
			yTx2	:= CONCAT(aSys.DiskHed.Disk[2].path, 'LOG/');
			yTx1	:= CONCAT(yTx2, yTx1, '.DIR'); //

	 	10:	// create path in version after restart {FRM}
			yTx2 	:= CONCAT(aSys.DiskHed.Disk[1].path, _NH2_VER, '/DBX/', DT_TO_STRINGF(aSys.NhDT, '%TYY_MM_DD/'));
			yTx1	:= CONCAT(aSys.DiskHed.Disk[1].path, yTx1, '.DIR'); // actual dir for save file rrmmddhh.mem
			aSys.ADR_DBX := yTx2;
  	 100:	// LOG evn 'RAM/'
			yTx1	:= CONCAT(aSys.DiskHed.disk[4].path, 'evn_', DT_TO_STRINGF(aSys.NhDT, '%TYYMM'), '.csv' );
//			yTx1	:= CONCAT('WWW/LOGS/EVN_',DT_TO_STRINGF(aSys.NhDT,'%TYYMM.LOG') );
			IF aSys.restart THEN
//				rb := FileDelete(fileName := yTx1);
			END_IF;
			RETURN;


	 	21:	//NH2
			yTx1 	:= aSys.DiskHed.Disk[1].path;					
			yTx2	:= '';
			CASE frm OF
(*
	 	1:	// create path in version after restart {FRM}
			yTx2 	:= CONCAT(aSys.DiskHed.Disk[1].path, _NH2_VER, '/', fN, '/');
			yTx1	:= CONCAT(aSys.DiskHed.Disk[1].path, yTx1, '.DIR'); // actual dir for save file rrmmddhh.mem
*)
				1:	// source FRM, 
//					yTx1 	:= CONCAT(yTx1, _NH2_VER, '/FRM/');											
					yTx2	:= CONCAT(yTx1, _NH2_VER, '/FRM/');
					RETURN;
				2:	// read path from dbx.mem to yTx2
					yTx1 	:= CONCAT(yTx1, 'dbx.NH2');													// file with actual path to backup file
					read	:= TRUE;
				3:	// rename .wrk -> .mem file after writing successfully
					yTx2	:= CONCAT(yTx1, 'dbx.wrk');													// dest file for rename		
					yTx1	:= CONCAT(yTx1, 'dbx.NH2');													// source file for rename	
					rb		:= FileDelete(fileName := yTx1);												// delete dbx.NH2
					rb		:= FileRename(oldName := yTx2, newName := yTx1);						// rename dbx.wrk -> dbx.NH2
					read	:= TRUE;
			END_CASE;

	 	22:	// USB
				yTx1 	   := aSys.DiskHed.Disk[2].path;					
				month 	:= TRUE;
				xTx1		:= ADR(yTx1);
				CASE frm OF
					0: 	RETURN;
					1:		// DBX FILE
							yTx1 	:= CONCAT(yTx1, _NH2_VER, '/DBX/');						            // CPU=2000log file
							CASE wh2 OF
								0: ;		
								1:	// add export cib file : .../V21/YYYY_MM/21_1454.cib
									DD_hhmm:=TRUE; suffix:=TRUE; fN:='cib'; 						
								2:	// create wrk file at the beginning of the recording backup RBx->file 'NH2/002/2025_01/25_1030.DBX';	// new backup file
									yTx2 	:= yTx1;	xTx1 := ADR(yTx2);										// dest path for dbx.wrk
									yTx1	:= CONCAT(aSys.DiskHed.Disk[1].path, 'dbx.wrk');			// NH2/dbx.wrk
									DD_hhmm:=TRUE; suffix:=TRUE; fN:='DBX'; write:=TRUE; 				// insert path to yTx2 + suffix and write to dbx.wrk
							END_CASE;
					2:		// log FILE
							CASE wh2 OF
								0:	yTx1 	:= CONCAT(yTx1, 'LOG/');						
								1:	yTx1 	:= CONCAT(yTx1, 'LOG/MSG/');						
								2:	yTx1 	:= CONCAT(yTx1, 'LOG/ALA/');						
								3:	yTx1 	:= CONCAT(yTx1, 'LOG/EVN/');						
								4:	yTx1 	:= CONCAT(yTx1, 'LOG/HET/');						
							ELSE	RETURN;
							END_CASE;
				 	100: 	//  ???? log NAME
				END_CASE;
	 	23: 	// SDC
//				yTx1 	:= CONCAT(aSys.DiskHed.Disk[3].path, 'TST/');					         	// test copy for faster run  
				RETURN;

	 	24:	// RAM
				yTx1 	:= aSys.DiskHed.Disk[4].path;					                  				// FRM copy for faster run
				IF wh2 = 0 THEN
					yTx2 	:= CONCAT(yTx1, 'SYS/');															// system wrk dir		
				ELSE
					yTx2 	:= CONCAT(yTx1, 'USR/',USINT_TO_STRINGF(wh2,'%02d/'));					// user wrk dir		
				END_IF	
				CASE frm OF
					1: // all about FRM an Copy
						yTx1 	:= CONCAT(yTx1, 'FRM/');					              					// FRM copy for faster run
						CASE wh2 OF
							0:	;	
							1:	// copy V200/FRM -> RAM/FRM
								yTx2 	:= yTx1; 																	// dest RAM/FRM/
								yTx1 	:= CONCAT(aSys.DiskHed.Disk[1].path, _NH2_VER, '/FRM/');		// source copy SYS/VER/FRM/
							2:	// copy log file
      						yTx1 	:= CONCAT(aSys.DiskHed.Disk[4].path, '_nh_copy.log');										// log file for copy dir/file
							3:	// lang file
								yTx0	:= CONCAT(yTx1,'_NhLang.NH2');										// lang translate file	
						END_CASE;

					2:	// usr-user wrk DIR 
						yTx1 	:= yTx2;					// user dir
					3:	// usr DIR LOG
//						yTx1 	:= CONCAT(yTx2,'PLC_DIR.log');
						yTx1 	:= CONCAT(yTx1,'PLC_DIR.log');
					4:	// usr FILE LOG 
//						yTx1 	:= CONCAT(yTx2,'PLC_FILE.log');
						yTx1 	:= CONCAT(yTx1,'PLC_FILE.log');
					5:	// TST/DEL log 
//						yTx2 	:= CONCAT(aSys.DiskHed.Disk[2].path, 'LOG/');		
						yTx2 	:= yTx1;
						CASE wh2 OF
							1:		yTx2 	:= CONCAT(yTx2,'TST_');
							2: 	yTx2 	:= CONCAT(yTx2,'DEL_');
						END_CASE;
						yTx1 	:= CONCAT(yTx2,DT_TO_STRINGF(aSys.NhDT, '%TYYMM.log') );						
					7:	// read for _NhIsObrOk
						yTx2 	:= CONCAT('_',UINT_TO_STRINGF(obr,'%03u'));
						yTx1	:= CONCAT(yTx1, 'FRM/', yTx2, '.FRM');
(*
	 	7:	// read template from RAM/FRM/_231.FRM
//	yTx0 := CONCAT('_',UINT_TO_STRINGF(frm,'%03u'));
//	yTx0 	:= CONCAT(aSys.DiskHed.Disk[4].path,'FRM/',yTx0,'.FRM');							// RAM/
         	yTx1 	:= CONCAT('_', UINT_TO_STRINGF(frm, '%03u'));
			yTx2	:= CONCAT(aSys.DiskHed.Disk[4].path, 'FRM/', yTx1, '.FRM');
			RETURN;
*)
				END_CASE;
				RETURN;
		ELSE
				rb := _NhSysLogMsg(noTime:=1,
									msg:='   !!! Err _Nh_Log_PATH: wh:'+ USINT_TO_STRING(wh)
											+ ' frm:' + UINT_TO_STRING(frm)
											+ ' wh2:' + USINT_TO_STRING(wh2)
											+ ' fN:{' + fN+ '}'
											+ ' DD_hh:'		+BOOL_TO_STRINGF(DD_hh,'%b{Y^N}')
											+ ' DD_hhmm:' 	+BOOL_TO_STRINGF(DD_hhmm,'%b{Y^N}')
											+ ' sufix:' 	+BOOL_TO_STRINGF(suffix,'%b{Y^N}')
											+ ' month:' 	+BOOL_TO_STRINGF(month,'%b{Y^N}')
											+ ' read:' 		+BOOL_TO_STRINGF(read,'%b{Y^N}')
											+ ' write:' 	+BOOL_TO_STRINGF(write,'%b{Y^N}')
											+ ' restart:' 	+BOOL_TO_STRINGF(restart,'%b{Y^N}')
											); 



(*
	 	4:	// create path in RAM, if exist - for faster run
//			month := false;
			yTx2 	:= CONCAT(aSys.DiskHed.Disk[4].path, fN, '/');
			yTx1	:= CONCAT(aSys.DiskHed.Disk[1].path, yTx1, '.DIR'); // actual dir for save file rrmmddhh.mem

	 	5:	// copy 
 			CASE frm OF                                                                         // template of copy src* -> dst*
				0:	// copy V200/FRM -> RAM/FRM
					yTx3 	:= CONCAT(aSys.DiskHed.Disk[1].path, _NH2_VER, '/FRM/');			   // source
					yTx4 	:= CONCAT(aSys.DiskHed.Disk[4].path, 'FRM/'); 		// dest
			END_CASE;
			RETURN;
	 	6:	// log DIR + copy dir/file
 			CASE frm OF                                                                         // template log  of copy 
				0:	// copy V200/FRM -> RAM/FRM
      			yTx1 	:= CONCAT(aSys.DiskHed.Disk[4].path, '_CopyDir.log');							// log file for copy dir/file
			END_CASE;
			RETURN;
*)

	END_CASE;
	IF month THEN										// add month DIR
		xTx1^	:=  CONCAT(xTx1^,aSys.YYYY_MM);
	END_IF
	IF DD_hh OR DD_hhmm THEN						// add to file day_time file	..../07_21
		xTx1^	:=  xTx1^ + CONCAT(USINT_TO_STRINGF(aSys.DAY, '%02d'),'_',TIME_TO_STRINGF(aSys.NhTime, '%Thh')) ;
		IF DD_hhmm THEN								// .../07_2143
			xTx1^	:=  CONCAT(xTx1^, TIME_TO_STRINGF(aSys.NhTime, '%Tmm')) ;
		ELSE												// .../07_2100
	//		xTx1^	:=  CONCAT(xTx1^, '00' );
		END_IF;	
	END_IF	
	IF suffix THEN						// add suffix
		xTx1^	:= CONCAT(xTx1^, '.',fN); 	
	END_IF;
	IF write THEN
		_Nh1RowTxt(write := TRUE); 				// write yTx2 to file xTx1 + add 'CFLF'
	ELSIF read THEN
		_Nh_Log_Path := _Nh_Line_RW(fH := fH, mode := 0, Read255 := 1, fExist := 1);
	END_IF;
END_FUNCTION

FUNCTION _NhCloseAllFiles {HIDDEN}: BOOL
	VAR_INPUT
		open:		BOOL := TRUE;
	END_VAR
	aSys.OpenFilesCount		:= OpenFilesCount();
	rb 							:= CloseAllFiles();
	aSys.LogHed.fhEvn 		:= INVALID_HANDLE_VALUE;
	aSys.LangfH 				:= INVALID_HANDLE_VALUE;
//	IF open THEN
//		rb	:=	_Nh_Log_PATH(wh:=24, frm:=3);
//		rb := _NHFopen(fN:=yTx1, fH:=aSys.LangfH);
//	END_IF;
	_NhCloseAllFiles	:= TRUE;
END_FUNCTION

FUNCTION _Nh_Lang {HIDDEN}: BOOL // nazov suboru obrazka
   VAR_INPUT
		close:	BOOL;		// close langFile after read
		wht: 		USINT; 	// 0=z Lava, 1=z lava aj zprava, 2=zlava, vsetky medzery		
      id: 		INT;		// ID = row _NhLang.NH2
      txt: 		PTR_TO STRING[30]; 	// pointer premennej
      zn: 		USINT := 30; 			// pocet znakov premennej
   END_VAR
	IF aSys.LangfH = INVALID_HANDLE_VALUE THEN
		rb	:=	_Nh_Log_PATH(wh:=24, frm:=1, wh2:=3);
  		aSys.LangfH := FileOpen(fileName := yTx0, mode := F_READ);
	END_IF;	
	rb	:= FileSetPos(hFile := aSys.LangfH, offset := INT_TO_UDINT(id - 1) * 64);
   IF FileRead (hFile := aSys.LangfH, adrBuf := PTR_TO_UDINT(txt), size := USINT_TO_UDINT(zn)) > 0 THEN
		txt^	:= LEFT(txt^,zn);
//		rb	:=	_NhSysLogMsg(msg:=INT_TO_STRINGF(id,'%4u')+'  {'+txt^+'}',maxSize:=0);
		_Nh_Lang := aTrim(wht := wht, txt := txt);
	ELSE	
//		rb	:=	_NhSysLogMsg(msg:='N '+ INT_TO_STRINGF(id,'%4u')+'  {'+txt^+'}',maxSize:=0);
		_Nh_Lang := FALSE;
     	txt^ 		:= '_NhLang.NH2 ?';
	END_IF;
	IF close THEN
		rb := _NhFclose(fH:=aSys.LangfH);		
	END_IF;	
END_FUNCTION

FUNCTION _NhOulog {HIDDEN}: BOOL
	VAR_INPUT
		ms : 	STRING;
      go :  USINT;
	END_VAR
	VAR_IN_OUT
		io :		NH_IO_BUSY;
	END_VAR	
	_NhOulog := TRUE;
	rb:=_NhSysLogMsg(msg:=BOOL_TO_STRINGF(io.exec,'%b{X^ }')
								+BOOL_TO_STRINGF(io.busy,'%b{B^ }')
								+BOOL_TO_STRINGF(io.done,'%b{D^ }')
								+BOOL_TO_STRINGF(io.err,'%b{E^ }')
								+BOOL_TO_STRINGF(io.found,'%b{F^ }')
								+'  Go: '+USINT_TO_STRINGF(go,'%3u')
								+'  Cs: '+UDINT_TO_STRINGF(io.cycSize,'%5u; ')
								+'  Rs: '+UDINT_TO_STRINGF(io.reqSize,'%5u; ')
								+'  As: '+UDINT_TO_STRINGF(io.actSize,'%5u; ')
								+ms
								,noTime:=1,noIni:=1);

END_FUNCTION


FUNCTION _Nh_Ou_Err {HIDDEN}: BOOL	// if err, find the err text, compose a message and write it to yTx0 and next to syslog
	VAR_INPUT
		errTxt :		BOOL:=TRUE;			// find text of Err.Message to yTx0
		sysLog :		BOOL:=TRUE;			// write to syslog
		msgFirst :	BOOL:=TRUE;			// msg+yTx0	or yTx0+msg
		noTime : 	BOOL:=TRUE;			// without timestamp
		errTyp :		SINT:=-1;			// -1: no Entry Error, 0=Sys, 1=NachHouse, 2=Sys+Nh
		ErrID :		UDINT;				// if errTyp>-1 sets io.errID		
		msg :			STRING[30];		   // additional message
	END_VAR
	VAR_IN_OUT
		io :			NH_IO_BUSY;			 	
	END_VAR	
	VAR_TEMP
		wrk :			STRING[30]; 			
	END_VAR 
	IF errTyp > -1 THEN										// manually sets from local calling
		io.err		:= TRUE;									
		io.errTyp 	:= errTyp;								// must be input
		io.errID 	:= errID;		
	END_IF;	
	_Nh_Ou_Err	:= io.err;
	IF io.err THEN												// any error
		
		io.busy 	:= FALSE;									
		io.found	:= FALSE;									
		io.done 	:= TRUE;										

		IF errTxt = FALSE	THEN								
			yTx0 := '';		
   	ELSIF io.errTyp=2 THEN								// get lang.text + msg + system  text error
			rb 	:= GetLastErrTxt(errCode := GetLastErr(), errMessage := yTx0);				// 2.Get Sys Text
			wrk	:= yTx0;
			rb 	:= _Nh_Lang(id:=UDINT_TO_INT(io.errID),wht:=1,txt:=ADR(yTx0),close:=TRUE);		// 1.Get text from _NhLang
			yTx0 	:= CONCAT(yTx0,' ',msg,'; errID: ',UDINT_TO_STRING(io.errID),' txt: ',wrk,'; ');
			errTxt:= FALSE;
		ELSIF io.errID = 1 THEN									// get lang.text + msg + system  text error
			rb := _Nh_Lang(id:=UDINT_TO_INT(io.errID),wht:=1,txt:=ADR(yTx0) );
		ELSIF io.errID = 0 THEN									// sys err not input, next  get syserr
      	io.errID := GetLastErr();
			rb := GetLastErrTxt(errCode := io.errID, errMessage := yTx0);
		ELSE 															// sys error is entered 			
			rb := GetLastErrTxt(errCode := io.errID, errMessage := yTx0);
      END_IF;
		IF errTxt	THEN											// compose err.mst
			yTx0	:= CONCAT(yTx0,'; errID:{',UDINT_TO_STRING(io.errID),'} txt:{',yTx0,'}; ');
			IF msg = ''  THEN					//  
				;
			ELSIF msgFirst THEN
				yTx0	:= CONCAT(msg,yTx0);
			ELSE
				yTx0	:= CONCAT(yTx0,msg);
			END_IF;		
		END_IF;
		IF sysLog	THEN											// write err message, yTx2 = option
			rb:=_NhSysLogMsg(msg:=yTx0, noTime:=noTime);
		END_IF;			
   END_IF;
END_FUNCTION

FUNCTION _Nh_File_Mem {HIDDEN}: BOOL
   VAR_INPUT
      write: BOOL;
      what: USINT;
      aVar: UDINT;
      size: UDINT;
      fH: HANDLE;
   END_VAR
	fRW	:= 0;
   IF write THEN
      CASE what OF
        0: fRW := FileWrite (hFile := fH, adrBuf := aVar, size := size);
        1: fRW := FileWriteRBx (hFile := fH, adrRBx := aVar, size := size);
      END_CASE;
   	aVar	:= fRW;
   ELSE
      CASE what OF
        0: fRW := FileRead (hFile := fH, adrBuf := aVar, size := size);
        1: fRW := FileReadRBx (hFile := fH, adrRBx := aVar, size := size);
      END_CASE;
   	aVar	:= fRW / 4;
   END_IF;
  	aSys.RWtoFileCycle 	:= aSys.RWtoFileCycle + aVar;
   _Nh_File_Mem 			:= fRW = size;
END_FUNCTION

FUNCTION_BLOCK _Nh_File_Line // zapisuje/cita/modifikuje riadok
	//	yTx0:='a.txt'; fbLine(open:=true,seek:=0,nLine:=1,sLine:=,aLine:=);		otvorit,vymazat,inicializovat
	// fbLine(close:=true,seek:=0);															len zatvorit
	// fbLine(write:=true,seek:=fbFileLine.LineS);
   (* close and delete file before open
      open a file from yTx5 (always F_READ_PLUS)
      seek: set
   *)
   VAR_INPUT
      what: 	USINT; 		// 0=Mem,1=RBx,2=DBx
      aLine: 	UDINT; 		//
		sLine: 	UDINT:= 1; 	// dlzka riadka vratane CRLF
      nLine: 	UDINT:= 1; 	// pocet riadkov pre zapis/nacitanie
      seek: 	UDINT; 		// set the beginning of this line
      open: 	BOOL; 		// najskor zatvori a nanovo otvori
      del: 		BOOL; 		// pred otvorenim vymaze
      close: 	BOOL; 		// na konci zatvori
      write: 	BOOL; 		// read=true:from File, read:=false: write To file
      append: 	BOOL;
   END_VAR
   VAR_OUTPUT
      ready: 	BOOL; 		// action is done
      done: 	BOOL;
      err: 		BOOL; 		// error flag
      rec: 		UDINT; 		// number of record
      LineS: 	UDINT; 		// the line number that was last loaded
      LineN: 	UDINT; 		// last number of lines, that were R/W
   END_VAR
   VAR
      fH:  		HANDLE;
      fS: 		UDINT; 		// fileSize
   END_VAR
   fRW := 0; err := FALSE; done := FALSE;
   IF open THEN open := FALSE;
      err 	:= FALSE; LineS := 0; LineN := 0; ready := FALSE;
      rb 	:= _NhFclose(fH := fH);
      IF del THEN del := FALSE;
         rb := fileDelete(fileName := yTx0);
      END_IF;
      IF _NhFopen(fN := yTx0, fH := fH, mode := 3) THEN
         ready := TRUE;
         fS 	:= FileSize(hFile := fH);
         rec 	:= fS / sLine;
      ELSE
         RETURN;
      END_IF;
   ELSIF ready = FALSE THEN
      RETURN;
   END_IF;
   IF seek > 0 THEN
      IF seek > rec THEN
         IF write THEN
            append := TRUE;
         ELSIF append THEN ;
         ELSE
            err := TRUE;
// done := true;
            LineS := 0;
            LineN := 0;
         END_IF;
      ELSE
         rb := FileSetPos( hFile := fH, offset := (seek - 1) * sLine);
   		err := _Nh_File_Mem(write := write, what := what, aVar := aLine, size := sLine * nLine, fH := fH) = FALSE;
         IF fRW >= sLine THEN
            LineS := seek;
            LineN := fRW / sLine;
         	done := TRUE;
         ELSE
            LineS := 0;
            LineN := 0;
         END_IF;
         append := FALSE;
      END_IF;
   END_IF;
   IF append THEN append := FALSE;
      rb := FileSetPos( hFile := fh, offset := fS);
      err := _Nh_File_Mem(write := TRUE, what := what, aVar := aLine, size := sLine * nLine, fH := fH) = FALSE;
      IF fRW >= sLine THEN
         LineS := fS / sLine;
         LineN := fRW / sLine;
      ELSE
         LineS := 0;
         LineN := 0;
      END_IF;
      fS := fS + fRW;
   END_IF;
   IF fRW > 0 THEN
      rec := fS / sLine;
   END_IF;
   IF close THEN
      rb := _NhFclose(fH := fH);
      ready := FALSE;
      close := FALSE;
   END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK _Nh_File_RW // zapisuje/cita zo suboru do premennej. Premenna moze byt v MEM,RAM,DBX
	(*
	- call 2x, 1.init+open, 2.run
	- init: go 1 .. 13 , in yTx0:=fN must be !! 
	 *)
   VAR_INPUT
      io :     	NH_IO_BUSY;
		aVar :		UDINT;	// adresss  from/to read
      Line : 		BOOL; 	// reads 255b and looks for CRLF and sets position to the next line
      Full :		BOOL; 	// Load the full size of the file detected after opening. Only read from file. {mode:=0}
		append :		BOOL;
		syslog :		BOOL;		// TRUE=write error to log and leave the error message in yTx0,  FALSE= not write onle leave in yTx0 
   END_VAR
   VAR
      fH : 			HANDLE;
    	mode : 		TF_MODE; 			// 0=F_READ,1=F_WRITE,2=F_APPEND {ak je seek=0 => append na koniec, seek>0..zapise na pozociu seek}
   END_VAR
	CASE io.go OF
		0: 	RETURN;
		// MEM
		1:		io.go := 101; mode:=0; 	// <- file		
		11:	io.go := 111; mode:=1;	// -> file	
		// RBx
		2:		io.go := 102; mode:=0; 	// <- file		
		12:	io.go := 112; mode:=1;	// -> file	
		// DBX
		3:		io.go := 103; mode:=0; 	// <- file		
		13:	io.go := 113; mode:=1;	// -> file	

		101:	IF line THEN
               xTx2 	:= UDINT_TO_PTR(aVar);
  	            fRW 	:= FileRead(hFile := fH, adrBuf := aVar , size := 255); // start at position actSize
					aSys.RWtoFileCycle := aSys.RWtoFileCycle + fRW / 2;
        	      IF fRW > 0 THEN // 1 4 6
           	      io.cycSize := FIND(xTx2^, _NH_CRLF); // 'abcCRxyz'
              	   IF io.cycSize > 0 THEN // cycSize:=4
                 	   xTx2^ := LEFT(xTx2^, io.cycSize - 1); // 'abc' (4-1=3)
                    	io.found    := TRUE; // Out impulz
                     io.cycSize  := io.cycSize + 1;
  	                  fRW         := io.cycSize; // '...CRxzy'
     	               rb          := FileSetPos(hFile := fH, offset := io.actSize + fRW ); // next line position 'xyz' ( 4+2{CRLF}=6)
        	         ELSE
           	         io.cycSize  := fRW; // actual position = next line
             		END_IF;
            	END_IF;
				ELSE fRW := FileRead		(hFile := fH, adrBuf := aVar + io.actSize, size := io.cycSize);
				END_IF;	
		111:	fRW := FileWrite		(hFile := fH, adrBuf := aVar + io.actSize, size := io.cycSize);		

		102:	fRW := FileReadRbx	(hFile := fH, adrRbx := aVar + io.actSize, size := io.cycSize);		
		112:	fRW := FileWriteRbx	(hFile := fH, adrRbx := aVar + io.actSize, size := io.cycSize);		

		103:	// file->mObr->DBX
				io.cycSize 	:= MIN(io.cycSize, _Nh_D12(aSys.mSecMax > aSys.mSecLimit,512,SIZEOF(mObr)));
				fRW := FileRead		(hFile := fH, adrBuf := PTR_TO_UDINT(ADR(mObr)), size := io.cycSize);
				IF WriteToDBx	(dataBoxAddress := aVar + io.actSize, varAddress := aVar + io.actSize,length := fRW) = FALSE THEN		
					fRW := 0;		
				END_IF;		
		113:	// DBX->mObr->file
				io.cycSize 	:= MIN(io.cycSize, _Nh_D12(aSys.mSecMax > aSys.mSecLimit,512,SIZEOF(mObr)));
				fRW := 0;
				IF ReadFromDBx	(dataBoxAddress := aVar + io.actSize, varAddress := PTR_TO_UDINT(ADR(mObr)),length := io.cycSize) THEN		
					fRW := FileWrite	(hFile := fH, adrBuf := PTR_TO_UDINT(ADR(mObr)), size := io.cycSize);		
				END_IF;
		99:	// cancel
				io.busy := FALSE; io.exec := FALSE; io.done := TRUE;
	ELSE 		// unknown command
				io.go := 0;
				RETURN;
	END_CASE;
	io.cyc := io.cyc + 1;
	IF io.exec THEN	io.exec := FALSE;		
		// exec,busy:  already=TRUE from ou:=_eIoDone;
		IF line  THEN	
			mode := F_READ;															// read line after line
		END_IF;
		IF mode = F_READ THEN ;
		ELSIF append THEN
			mode := F_APPEND;															// read line after line
		ELSE
			mode := F_WRITE;															// read line after line
		END_IF;
		IF _NhFopen(fN := yTx0, fH := fH , mode := mode, log:=0 ) = FALSE THEN	 // (DBX W/R), close file
			rb	:= _Nh_Ou_Err(sysLog:=0, io:=io, msg:='{'+yTx0+'}', errTyp:=2, ErrID:=1002);
     	ELSIF Line OR full THEN
      	io.reqSize := fS; 		// the file size is in the variable fS after opening. The full size is loaded
     	END_IF;
		io.cycSize 	:= MIN(io.reqSize - io.actSize, _Nh_D12(aSys.mSecMax > aSys.mSecLimit,512,_NH_CLUSTER));
		IF io.err THEN	
			io.done := TRUE;
		ELSE
			RETURN;			
		END_IF;
	ELSIF io.busy THEN
		io.actSize	:=	io.actSize + fRW;
     	IF fRW <> io.cycSize THEN 			// the request did not proceed correctly
			rb	:= _Nh_Ou_Err(sysLog:=0,io:=io, msg:='; fRW: '+UDINT_TO_STRING(fRW)+' cycSize: '+UDINT_TO_STRING(io.cycSize), errTyp := 2, ErrID := 1004);
		ELSIF io.reqSize > io.actSize THEN
			io.cycSize 	:= MIN(io.reqSize - io.actSize, _Nh_D12(aSys.mSecMax > aSys.mSecLimit,512,_NH_CLUSTER));
		ELSE
			io.done		:=	TRUE;
		END_IF;
	END_IF;
	IF io.done THEN	io.busy := FALSE;
      rb 	:= _NhFclose(fH := fH);
		io.go := 0;
	END_IF;
END_FUNCTION_BLOCK

(*
FUNCTION_BLOCK _Nh_File_RWo // zapisuje/cita zo suboru do premennej. Premenna moze byt v MEM,RAM,DBX
   VAR_INPUT
		go :			USINT;
      io :     	NH_IO_BUSY;
		aVar :		UDINT;	// adresss  from/to read
      Line : 		BOOL; 	// reads 255b and looks for CRLF and sets position to the next line
      Full :		BOOL; 	// Load the full size of the file detected after opening. Only read from file. {mode:=0}
   END_VAR
   VAR_IN_OUT
      fN : 			STRING; // file name
   END_VAR
   VAR
      fH : 			HANDLE;
    	mode : 		TF_MODE; 			// 0=F_READ,1=F_WRITE,2=F_APPEND {ak je seek=0 => append na koniec, seek>0..zapise na pozociu seek}
   END_VAR
	CASE go OF
		0: 	RETURN;
		1:		// MEM
				IF io.mode = F_READ OR line  THEN // <- file	
					io.go := 10;
				ELSE 								// -> file	
					io.go := 11;
				END_IF;		
		2:		// RBx
				IF io.mode = F_READ THEN	// <- file	
					io.go := 20;
				ELSE 								// -> file	
					io.go := 21;
				END_IF;		
		3:		// DBX
				IF io.mode = F_READ THEN	// <- file	
					io.go := 30;
				ELSE 								// -> file	
					io.go := 31;
				END_IF;		

		10:	IF line THEN
               xTx2 	:= UDINT_TO_PTR(aVar);
  	            fRW 	:= FileRead(hFile := fH, adrBuf := aVar , size := 255); // start at position actSize
					aSys.RWtoFileCycle := aSys.RWtoFileCycle + fRW / 2;
        	      IF fRW > 0 THEN // 1 4 6
           	      io.cycSize := FIND(xTx2^, _NH_CRLF); // 'abcCRxyz'
              	   IF io.cycSize > 0 THEN // cycSize:=4
                 	   xTx2^ := LEFT(xTx2^, io.cycSize - 1); // 'abc' (4-1=3)
                    	io.found    := TRUE; // Out impulz
                     io.cycSize  := io.cycSize + 1;
  	                  fRW         := io.cycSize; // '...CRxzy'
     	               rb          := FileSetPos(hFile := fH, offset := io.actSize + fRW ); // next line position 'xyz' ( 4+2{CRLF}=6)
        	         ELSE
           	         io.cycSize  := fRW; // actual position = next line
             		END_IF;
            	END_IF;
				ELSE fRW := FileRead		(hFile := fH, adrBuf := aVar + io.actSize, size := io.cycSize);
				END_IF;	
		11:	fRW := FileWrite		(hFile := fH, adrBuf := aVar + io.actSize, size := io.cycSize);		

		20:	fRW := FileReadRbx	(hFile := fH, adrRbx := aVar + io.actSize, size := io.cycSize);		
		21:	fRW := FileWriteRbx	(hFile := fH, adrRbx := aVar + io.actSize, size := io.cycSize);		

		30:	// file->mObr->DBX
				io.cycSize 	:= MIN(io.cycSize, _Nh_D12(aSys.mSecMax > aSys.mSecLimit,512,SIZEOF(mObr)));
				fRW := FileRead		(hFile := fH, adrBuf := PTR_TO_UDINT(ADR(mObr)), size := io.cycSize);
				IF WriteToDBx	(dataBoxAddress := aVar + io.actSize, varAddress := aVar + io.actSize,length := fRW) = FALSE THEN		
					fRW := 0;		
				END_IF;		
		31:	// DBX->mObr->file
				io.cycSize 	:= MIN(io.cycSize, _Nh_D12(aSys.mSecMax > aSys.mSecLimit,512,SIZEOF(mObr)));
				fRW := 0;
				IF ReadFromDBx	(dataBoxAddress := aVar + io.actSize, varAddress := PTR_TO_UDINT(ADR(mObr)),length := io.cycSize) THEN		
					fRW := FileWrite	(hFile := fH, adrBuf := PTR_TO_UDINT(ADR(mObr)), size := io.cycSize);		
				END_IF;

		99:	// cancel
				io.Go := 0;		
				io.exec := FALSE; io.busy := FALSE;						// block

	ELSE 		// unknown command
				io.go := 0;
				RETURN;
	END_CASE;
	io.cyc := io.cyc + 1;





	IF io.exec THEN	io.exec := FALSE;		
		// exec,busy:  already=TRUE from ou:=_eIoDone;
		IF line  THEN	
			io.mode := F_READ;															// read line after line
		END_IF;
		IF _NhFopen(fN := fN, fH := fH , mode := io.mode, log:=0 ) = FALSE THEN	 // (DBX W/R), close file
			rb	:= _Nh_Ou_Err(io:=io, msg:=fN, errTyp:=2, ErrID:=1002);
     	ELSIF Line OR full THEN
      	io.reqSize := fS; 		// the file size is in the variable fS after opening. The full size is loaded
     	END_IF;
		io.cycSize 	:= MIN(io.reqSize - io.actSize, _Nh_D12(aSys.mSecMax > aSys.mSecLimit,512,_NH_CLUSTER));
		IF io.err THEN	
			io.busy := FALSE; io.done := TRUE;
		ELSE
			RETURN;			
		END_IF;
	END_IF;
	IF io.busy THEN	
		io.actSize	:=	io.actSize + fRW;
      IF fRW <> io.cycSize THEN 			// the request did not proceed correctly
			rb	:= _Nh_Ou_Err(io:=io, msg:='; fRW: '+UDINT_TO_STRING(fRW)+' cycSize: '+UDINT_TO_STRING(io.cycSize), errTyp := 2, ErrID := 1004);
		ELSIF io.reqSize > io.actSize THEN
			io.cycSize 	:= io.reqSize - io.actSize;			
		ELSE
			io.done		:=	TRUE;
		END_IF;
		io.cycSize 	:= MIN(io.cycSize, _Nh_D12(aSys.mSecMax > aSys.mSecLimit,512,_NH_CLUSTER));
	END_IF;
	IF io.done THEN	io.busy := FALSE;
      rb := _NhFclose(fH := fH);
		io.go := 0;
	END_IF;
END_FUNCTION_BLOCK
*)

(*
FUNCTION_BLOCK _Nh_File_RWo // zapisuje/cita zo suboru do premennej. Premenna moze byt v MEM,RAM,DBX
	// moze nacitat aj riadok ukonceny CRLF, pricom nie je pevna dlzka riadka
	// Copy data from/to variable/RamBox to/from file.
   // If file does not exist new file is created.
   // If file exists file content is overwitten.
   // these global variables that must exist are overwritten: fS,fP,fRW
   VAR_INPUT
      io :     	NH_IO_BUSY;
		// io.start  		// only init and back from FB
		// io.seek 			// adresss vas from/to read
		// io.what			// what is in adrVar 0=MEM, 1=RamBox, 2=DataBox
      Line: 		BOOL; 	// reads 255b and looks for CRLF and sets position to the next line
      AllFile :	BOOL; 	// Load the full size of the file detected after opening. Only read from file. {mode:=0}
//      adrVar: 	UDINT; 	// adress: variable/Ram/Dbx address {it is entered at the beginning and cannot be changed after that !!!}
//		size: 	UDINT;	// total required data size
//      seek: 	UDINT; 	// data offset in file {it is only taken over at the beginning, after that it has no effect}
//      whatVar: USINT; 	
      mode : 		TF_MODE; // 0=F_READ,1=F_WRITE,2=F_APPEND {ak je seek=0 => append na koniec, seek>0..zapise na pozociu seek}
   END_VAR
   VAR_IN_OUT
      fN : 			STRING; // file name
   END_VAR
   VAR
      fH : 			HANDLE;
   END_VAR
   io.done := FALSE; //io.found := FALSE;
    // open file and seek position
	IF io.exec THEN io.exec := FALSE;
//		exec := FALSE; io := _eIOBusy;  //busy := TRUE; actSize := 0; cyc := 0; errID := 0; errOwn := FALSE;
      IF line THEN
         mode := F_READ;															// read line after line
      END_IF;
//		io.go :=	io.what;
		IF _NhFopen(fN := fN, fH := fH , mode := mode, log:=0 ) = FALSE THEN	 // (DBX W/R), close file
			rb	:= _Nh_Ou_Err(io:=io, msg:=fN, errTyp:=2, ErrID:=1002);
      ELSIF Line OR allFile THEN
         io.reqSize := fS; 		// the file size is in the variable fS after opening. The full size is loaded
      END_IF;
		IF io.start THEN io.start := FALSE; 
			RETURN;
		END_IF;	
	ELSIF io.cancel	THEN
		rb	:= _Nh_Ou_Err(io:=io, errTyp:=1, ErrID:=1003);
   END_IF;
	IF io.busy THEN
		io.cycSize 	:= MIN(io.reqSize - io.actSize, _Nh_D12(aSys.mSecMax > aSys.mSecLimit,512,_NH_CLUSTER));
		CASE io.what OF
			// Mem 1=write, 11:=read
         1:	 	fRW 	:= FileWrite( hFile := fH, adrBuf := io.seek + io.actSize, size := io.cycSize); 
			11: 	IF Line THEN	// read
	               xTx2 	:= UDINT_TO_PTR(io.seek);
   	            fRW 	:= FileRead(hFile := fH, adrBuf := io.seek , size := 255); // start at position actSize
						aSys.RWtoFileCycle := aSys.RWtoFileCycle + fRW / 2;
         	      IF fRW > 0 THEN // 1 4 6
            	      io.cycSize := FIND(xTx2^, _NH_CRLF); // 'abcCRxyz'
               	   IF io.cycSize > 0 THEN // cycSize:=4
                  	   xTx2^ := LEFT(xTx2^, io.cycSize - 1); // 'abc' (4-1=3)
                     	io.found    := TRUE; // Out impulz
	                     io.cycSize  := io.cycSize + 1;
   	                  fRW         := io.cycSize; // '...CRxzy'
      	               rb          := FileSetPos(hFile := fH, offset := io.actSize + fRW ); // next line position 'xyz' ( 4+2{CRLF}=6)
         	         ELSE
            	         io.cycSize  := fRW; // actual position = next line
               		END_IF;
	            	END_IF;

   	         ELSE fRW 	:= FileRead(hFile := fH, adrBuf := io.seek + io.actSize, size := io.cycSize);
					END_IF;
         // RamBox
			2: 	fRW := FileWriteRbx(hFile := fH, adrRbx := io.seek + io.actSize, size := io.cycSize);
         12: 	fRW := FileReadRbx( hFile := fH, adrRbx := io.seek + io.actSize, size := io.cycSize);
        // DataBox
			3: ;
         13: ;
		ELSE 	
			rb	:= _Nh_Ou_Err(io:=io, errTyp:=99);					
			fRW:=0; io.cycSize:=0; 
		END_CASE;
		io.actSize	:=	io.actSize + fRW;
      IF fRW <> io.cycSize THEN 			// the request did not proceed correctly
			rb	:= _Nh_Ou_Err(io:=io, msg:='; fRW: '+UDINT_TO_STRING(fRW)+' cycSize: '+UDINT_TO_STRING(io.cycSize), errTyp := 2, ErrID := 1004);
		ELSIF io.reqSize > io.actSize THEN
			io.cycSize 	:= io.reqSize - io.actSize;			
		ELSE
			io.done		:=	TRUE;
		END_IF;
	END_IF;

	io.cyc := io.cyc + 1;
   IF io.done THEN
//		rb		:= _Nh_Ou_Err(ou:=ou, msg:=eTxt, sysLog:=FALSE);   // insert errtextMessage into yTx0, no Write to Log
      rb 			:= _NhFclose(fH := fH);
      io.cancel	:=FALSE;	
		io.busy		:=FALSE;
   END_IF;
END_FUNCTION_BLOCK
*)

FUNCTION_BLOCK _Nh_TONF {HIDDEN} 	// opozdenie v [sec/Min/Hour] In->Out po zapnuti aj vypnuti s autoresetom
  	VAR_INPUT
		PT: UINT; 		// delay po zapnuti [sec]
      wht: USINT;
  		In: BOOL; 	// vstup
		rst: BOOL;
  	END_VAR
	VAR
		InOld: BOOL;
	END_VAR
	VAR_OUTPUT
		Q: BOOL;							// vystup
		Qr: BOOL; 	// impulz pri ON
		Qf: BOOL; 	// impulz pri Off
		ET: UINT;
	END_VAR
	Qr 	:= FALSE;
	Qf 	:= FALSE;
	IF rst OR InOld <> In THEN 									// reset
		ET 	:= PT;										// prida sa 1sec aby sa vyhodnotilo ET
		Q		:= 0; // NOT in;
		rst 	:= FALSE;
		InOld := In;
	ELSIF et > 0 THEN // bezi opozdenie
      CASE wht OF
        0: et := et - BOOL_TO_UINT(SYSTEM_S.F_EDGE_1SEC);
        1: et := et - BOOL_TO_UINT(SYSTEM_S.F_EDGE_1MIN);
        2: et := et - BOOL_TO_UINT(SYSTEM_S.F_EDGE_1HOUR);
      END_CASE;
		IF et = 0 THEN											// minimum je 1, co sa chape ako OK
			et	:= 0;
         Q := In;
			Qr := Q;
			Qf := Q = FALSE;
		END_IF;
   ELSE
      Q := In;
   END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK _Nh_TONOF {HIDDEN} 	// opozdenie v [sec] In->Out po zapnuti aj vypnuti s autoresetom
  	VAR_INPUT
		tOn: UINT; 		// delay po zapnuti [sec]
		tOf: UINT;							// delay po vypnuti [sec]
		In: BOOL; 	// vstup
		rst: BOOL;
  	END_VAR
	VAR
		InOld: BOOL;
	END_VAR
	VAR_OUTPUT
		Q: BOOL;							// vystup
		Qr: BOOL; 	// impulz pri ON
		Qf: BOOL; 	// impulz pri Off
		et: UINT;
	END_VAR
	Qr 	:= FALSE;
	Qf 	:= FALSE;
	IF rst OR InOld <> In THEN 									// reset
		IF In THEN
			et 	:= tOn + 1;										// prida sa 1sec aby sa vyhodnotilo ET
		ELSE
			et 	:= tOf + 1;
     	END_IF;
		IF RST THEN
			Q		:= 0;	// In; // resetne vystup
//			Q		:= NOT In; 	// pri in:=1 .. oneskorenie zapnutia Q:=0->1
																		// pri in:=0 .. oneskorenie vypnutia Q:=1->0
	 END_IF;
		rst 	:= FALSE;
		InOld := In;
	ELSIF et > 0 THEN // bezi opozdenie
		et := et - aSys.u1Sec;
		IF et <= 1 THEN											// minimum je 1, co sa chape ako OK
			et	:= 0;
			Q 	:= In;
			Qr := Q;
			Qf := Q = FALSE;
		END_IF;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK _Nh_U_Delay {HIDDEN} // opozdenie In->Out po ustaleni v case Delay
  	VAR_INPUT
		Delay: USINT; // opozdenie novej hod kazdenho noveho PV rozdielneho od aktualneho
		IN: BOOL; 	 	// nova hodnota
  	END_VAR
	VAR_OUTPUT
		Done: BOOL;
		Busy: BOOL;
		et: USINT; // cas delay v [s]
	END_VAR
	Done	:= FALSE;
	IF In THEN
		et	 	:= Delay;
		Busy	:= TRUE;
	ELSIF Busy THEN
		IF et > 0 AND SYSTEM_S.F_EDGE_1SEC THEN
			et := et - 1;
		END_IF;
		IF et = 0 THEN
			Done	:= TRUE;
			Busy	:= FALSE;
		END_IF;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK _Nh_R_Delay {HIDDEN} // opozdenie In->Out po ustaleni v case Delay
	VAR_OUTPUT
		dif: REAL;
		Out: REAL;							// aktualna hodnota / vystup
		et: USINT; // cas delay v [s]
		chg: BOOL; 	// zmenil sa vystup
	END_VAR
  	VAR_INPUT
		rst: BOOL; 						// restart {vstup revedie na vystup okamzite = bez Delay
		In: REAL; // nova hodnota
		Delay: USINT; 		// opozdenie novej hod kazdenho noveho PV rozdielneho od aktualneho
		Sens: REAL := 0.1;					// hysterezia = povolena odchylka
  	END_VAR
	VAR
		Old: REAL;							// posledna hodnota In
	END_VAR
	chg	:= FALSE;
//	in 	:= ROUND(in * 10.0) / 10.0;
	dif := Out - In;
	IF ABS(Out - In) <= sens	THEN
		et	:= 0;
	ELSIF rst OR Delay = 0 THEN
		Out := In;
		chg := TRUE;
	ELSIF Old <> In OR et = 0 THEN
		et	 	:= Delay;
		Old 	:= In;
	ELSE
		et := et - aSys.n1Sec;
		IF et = 0 THEN
			Out := In;
			chg := TRUE;
		END_IF;
	END_IF;
	chg	:= chg OR rst;
END_FUNCTION_BLOCK

FUNCTION_BLOCK _Nh_FILTER_1R {HIDDEN} // filer 1.radu
   VAR_INPUT
      In: REAL ; // nova hodnota zo snimaca (stara hodnota je v xDev^.al.in.val)
      fil: REAL := 10.0; // filtrovanie 1.radu
		hys: REAL := 0.1 ;		 // povolena odchylka
      sample: UINT := 30; // vzorkovacia frekvencia vydavania vystupu[s]
		rst: BOOL;		 // okamzite prenesenie vstupnej hodnoty na vustup
		rstBig: BOOL := TRUE	; 	 // resetne, ked je velka zmena - po restarte sa nastavi
   END_VAR
	VAR_OUTPUT
//		Run: BOOL; 				 // po restarte sa vyvola reset
		Qr: BOOL;					 // impulz pri zmene vystupu
		New: REAL; // nova vypocitavana hodnota podla filtra
		Out: REAL; // vystupna filtrovana hodnota zakomponovana aj s hystereziou vydana po vzorkovacej frekvencii
    	Qn: UINT; // zostatok [s] do vyslania noveho vystupu
		nBig: USINT;					 // pocet velkych zmien
	END_VAR
	Qr	:= FALSE;
   IF rst THEN // OR run = false THEN // okamzity prenos hodnoty (vyluci sa filter) reset vstupov
		rst	:= FALSE;
//		run	:= true;
		New 	:= In;
//		Out	:= New;
//		Qr		:= true;
      Qn 	:= 0;
   ELSIF SYSTEM_S.R_EDGE_100MS THEN
		New 	:= (New * fil + In ) / (fil + 1.0) ;
		IF rstBig THEN
			// ak sa caka na velku zmenu a ta je 100x vacsia ako vysledok, tak sa
			IF ABS(Out - In) > 100. * hys THEN
				nBig		:= nBig + 1;
				rstBig 	:= FALSE;
				New 		:= In;
		 Qn 		:= 0;
			END_IF;
		END_IF;

	END_IF
   IF Qn = 0 THEN
		IF ABS(New - Out) > hys THEN
			Qr := TRUE;
			Out := ROUND(new * 10.) * 0.1;
		END_IF;
		Qn :=	sample;
   ELSIF SYSTEM_S.R_EDGE_1SEC THEN
      Qn := Qn - 1;
   END_IF
END_FUNCTION_BLOCK








{ $DEFINE __NH_LIST_PLC_STRING }

TYPE
   NH_FRM_HED {HIDDEN}   : STRUCT      				// HLAVNA RIADIACA PREMENNA
      name     : STRING[5] :='_END';
		desc		: STRING[20];
      wht      : USINT;       	// 1-brw,2-FRM,3-MNU,4- HOME-PG - ALL, 0=read All file (log/230...) 
		row		: USINT:=1;       // numbrer of Rows
		sld		: USINT;    		// number of sliders
		siz		: UDINT;				// size all file (NH_FRM_HED+data)
	END_STRUCT;

	NH_PLC_DIR_DHED       : STRUCT   	// dir   
//      eTime   	: STRING[11] :='00:00:00.00'; stim 	: BYTE := 16#3b;
      dUp   	: STRING[1] :=' ';
		dEmpty	: STRING[1]	:=' ';
      dDT   	: STRING[19]:='                   ';
//		dName		: STRING;	//:='                                                                           ';
//      Cr       : BYTE   := 16#0D;
//      Lf       : BYTE   := 16#0A;
	END_STRUCT;

	{ $IFDEF __NH_LIST_PLC_STRING }
		NH_PLC_DIR_FHED       : STRUCT   // struktura EVN-log
//			aaa		: STRING[3]:= 'aaa';  s1 	: BYTE := 16#3b;
//			bbb		: STRING[3]:= 'bbb';  s2 	: BYTE := 16#3b;
   	   fLen   	: STRING[3] :='   ';
			DaysOld	: STRING[5] :='     ';
			fS			: STRING[6] :='      ';
	      fDT   	: STRING[19]:='                   ';
		END_STRUCT;
	{ $ELSE }
		NH_PLC_DIR_FHED       : STRUCT   // struktura EVN-log
   	   fLen   	: UDINT;	//STRING[3] :='   ';
			oldDays	: UINT;
			fS			: UDINT;	//STRING[10]:='          ';
	      fDT   	: DT;	//STRING[19];	//:='                   ';
		END_STRUCT;
	{ $END_IF }
	NH_PLC_DIR_DATA       : STRUCT   // struktura EVN-log
		dHed		: NH_PLC_DIR_DHED;			// DIR info
		dName		: STRING[100];	//:='                                                                           ';
		fHed		: NH_PLC_DIR_FHED;		// hed of file
		fName		: STRING[100];					// fileName
	END_STRUCT;

	NH_PLC_DIR_IO 	     : STRUCT   	// dir   
		lenRow:			USINT:=100;		// line length in file dir
//		lenPath:			USINT:=100;
		fPdir:			UDINT;	 		// DIR-file position for return back
		fSdir:			UDINT;			// DIR-file size
		hDir: 			HANDLE;
		hLsD: 			HANDLE;
		hLsF: 			HANDLE;
		Info: 			TFileInfo;
		DaysOld: 		LONGTIME; 			// log text length

		lifeSize:		ARRAY[0..1,0..4] OF UDINT;	//[lifeTime, 1/2lifeTime, 1/4lifeTime, oneMonth]
 	END_STRUCT;

	NH_PLC_DIR_MASK	: STRUCT   	// exluse/include/mask dir or filre
		exclDirs				:	STRING[36]	:= 'JS/;JSN/;LOGS/;NOTIFY/;IMAGES/;FRM/;';	// DIRs in which files are not deleted (Mosaic and NachHouse templates)
		exclRootFiles		:	STRING[17]	:= '//;//WWW/;//NH2/;';								// roor DIRS where files in not deleted
		exclSufixFile		:	STRING[10]	:= '.NH2;.FRM;';										// .TXT;.XML;.XLS;.JS;.ICO;.CSS; fufix files to exclude
//		exclEmptDir			:	STRING[13]	:=	'/USR/;/SYS/;';										// list of empty DIRs that will not be deleted
	END_STRUCT;
END_TYPE

FUNCTION _Nh_Chk_Mask {HIDDEN}: BOOL		// check if the file/dir matches the mask
	VAR_INPUT
		what:		SINT;	
	END_VAR
	VAR_IN_OUT
		path: 	STRING;
	END_VAR
	VAR_TEMP
		mask: 	NH_PLC_DIR_MASK;
//		wrk:		STRING[5];	
	END_VAR
	_Nh_Chk_Mask := FALSE;
	CASE what OF
		1: // exlcude Suffix
			yTx0			:= MID(path,4,FIND(path,'.'));
			yTx0			:= CONCAT(yTx0,';');
			_Nh_Chk_Mask 	:= FIND(mask.exclSufixFile, yTx0) > 0 ;
		2: // no-delete dir 
			yTx0				:= CONCAT(path,';');
			_Nh_Chk_Mask 	:= FIND(mask.exclDirs, yTx0) > 0 ;	// find p
		3: // sys dir mask - exlclude when chceck only SYS disk
			yTx0				:= CONCAT(path,';');
			_Nh_Chk_Mask 	:= FIND(mask.exclRootFiles, yTx0) > 0 ;
(*
		4: // dir from list found in path - Excl Empty Dir
			yTx0 := mask.exclEmptDir;
			del 	:= FIND(yTx0,';');
			WHILE del > 0 DO
				wrk := LEFT(yTx0,del-1);	
				IF FIND(path,wrk)	> 0 THEN
					_Nh_Chk_Mask := TRUE;
					EXIT;
				ELSE	
					yTx0	:= DELETE(yTx0,del,1);	
					del 	:= FIND(yTx0,';');
				END_IF;
			END_WHILE;
*)	
	ELSE _Nh_Chk_Mask := TRUE;
	END_CASE;
END_FUNCTION


VAR_GLOBAL
//	_Nh_Dir_Data	AT mObr 			{HIDDEN}: NH_PLC_DIR_DATA ;						// before yTx6
	_Nh_Dir_Data	 			: NH_PLC_DIR_DATA ;						// before yTx6
END_VAR



FUNCTION	_Nh_FIX_STRING_CRLF {HIDDEN}: BOOL	// fix end string and add spaces to lenngth
	VAR_INPUT
		lenTxt	:	INT;		// all length of string
	END_VAR	
	VAR_IN_OUT
		Txt		:	STRING;	// string
	END_VAR
	_Nh_FIX_STRING_CRLF := TRUE;
	memsetEx(val := 16#20202020, length 	:= INT_TO_UDINT(lenTxt) - LEN(txt) - 1    ,
											dest 		:= VOID(txt),
											offDest	:= LEN(txt) + 1  ); // vymaze zbytok stringu medzerami
	memsetEx(val := 16#0a0d, 	length 	:= 2, 
										dest 		:= VOID(txt),
										OffDest 	:= INT_TO_UDINT(lenTxt)-2 ); // + CRLF
END_FUNCTION


FUNCTION _Nh_PLC_DIR_Data_ADD {HIDDEN}: BOOL
	VAR_INPUT
		file:		BOOL; 
	END_VAR
	VAR_IN_OUT
		IO:		NH_PLC_DIR_IO;
//		Name: 	STRING;
	END_VAR	
	_Nh_PLC_DIR_Data_ADD	:= TRUE;	fRW := 0;
	IF file THEN
//		IF IO.DaysOld.Days >= UINT_TO_DINT(IO.LifeTime) THEN
//			IO.lifeSize[0] := IO.lifeSize[0] + info.fileSize;
//		END_IF;

		{ $IFDEF __NH_LIST_PLC_STRING }
(*
			yTx0	:= CONCAT(	DT_TO_STRINGF(IO.Info.modifyTime,'%TYYYY-MM-DD-hh:mm:ss;'),
									UDINT_TO_STRINGF(MAX(1,IO.info.fileSize / 1024),'%6d;'),
									_Nh_Dir_Data.fName 
			);
			fRW	:= FileWrite(hFile:=IO.hLsF ,adrBuf:=PTR_TO_UDINT(ADR(yTx0)), size:=LEN(yTx0));
*)	
			_Nh_Dir_Data.fHed.fDT		:= DT_TO_STRINGF(IO.Info.modifyTime,'%TYYYY-MM-DD-hh:mm:ss');
			_Nh_Dir_Data.fHed.fS			:= UDINT_TO_STRINGF(MAX(1,IO.info.fileSize / 1024),'%6d');
			sp									:= INT_TO_UDINT(LEN(_Nh_Dir_Data.fName)) + SIZEOF(_Nh_Dir_Data.fHed);
			_Nh_Dir_Data.fHed.fLen		:= UDINT_TO_STRINGF( sp,'%3u' );
			_Nh_Dir_Data.fHed.DaysOld	:= DINT_TO_STRINGF(IO.DaysOld.Days,'%5d');

		{ $ELSE }
			_Nh_Dir_Data.fHed.fDT		:= IO.Info.modifyTime;
			_Nh_Dir_Data.fHed.fS			:= MAX(1,IO.info.fileSize / 1024);
			_Nh_Dir_Data.fHed.fLen		:= INT_TO_UDINT(LEN(_Nh_Dir_Data.fName) + SIZEOF(_Nh_Dir_Data.fHed));
			sp									:= _Nh_Dir_Data.fHed.fLen;
		{ $END_IF }
		fRW	:= FileWrite(hFile:=IO.hLsF ,adrBuf:=PTR_TO_UDINT(ADR(_Nh_Dir_Data.fHed)), size:=sp );

	ELSIF FileSetPos( hFile := IO.hLsD, offset := IO.fSdir) THEN
		_Nh_Dir_Data.dHed.dUp 	:= ' ';													// flag for new DIR
		_Nh_Dir_Data.dHed.dDT	:= DT_TO_STRINGF(IO.Info.modifyTime,'%TYYYY-MM-DD-hh:mm:ss');
		_Nh_FIX_STRING_CRLF(txt	:=	_Nh_Dir_Data.dName, lenTxt	:= USINT_TO_INT(IO.lenRow) - SIZEOF(_Nh_Dir_Data.dHed));
		sp		:= USINT_TO_UDINT(IO.lenRow);
		fRW	:= FileWrite( hFile:=IO.hLsD ,adrBuf:=PTR_TO_UDINT(ADR(_Nh_Dir_Data.dHed)),size:=sp );					
		IO.fSdir := IO.fSdir + fRW;
		IO.fPdir	:= IO.fSdir;
	ELSE
		rb	:=	_NhSysLogMsg(noIni:=TRUE, msg:=' ! Err:_Nh_Dir_Data_ADD-1; fN={'+ _Nh_Dir_Data.dName + '}; fSdir='+UDINT_TO_STRING(IO.fSdir) );											
	END_IF;	
	IF fRW <> sp THEN
		rb		:=	_NhSysLogMsg(noIni:=TRUE, msg:=' ! Err:_Nh_Dir_Data_ADD-2; fN={'+ _Nh_Dir_Data.dName + '}; fRW: '+UDINT_TO_STRING(fRW));					
		_Nh_PLC_DIR_Data_ADD	:= FALSE;	
	END_IF;
END_FUNCTION

FUNCTION_BLOCK _Nh_PLC_DIR  // list DIR and save to file in RAM
	VAR_INPUT
		Go: 				USINT; 			// 1=start list DIR, 2=next entry, 0=stop
		dirName:    	STRING[40]; // DIR path is first condition, then Case disk
		usr:     		USINT;   	// make list to user work Dir (only when GoDelete=FALSE)
		lifeTime: 		UINT:=730; 	// how many days older files will be deleted/tested
		noSubDir:		BOOL;			//	Not go to Sudirectories			
		checkFile:		BOOL:=TRUE;	// first create list DIRs and check and writes files
		emptyDir:		BOOL:=TRUE;	// second check empty Dirs in list ONLY !! Empty DIRs (AND delete  IF GoDelete:=TRUE)
		// parameters Only for delete/test
		GoDelete:		BOOL:=TRUE;	// list DIRs without excludeDirs (files will remain) and net DELETE/TEST 
		testOnly: 		BOOL:=TRUE; // only tests, does not delete (only when GoDelete:=TRUE)
		append:			BOOL;			// append to DEL_RRMM.log (only if ) 
	END_VAR	
	VAR_OUTPUT
		busy: 			BOOL; 
		done: 			BOOL; 
		tree:				BOOL;			// 1.cycle = create DIR tree
		errID:			USINT;
		nCyc:				UINT;
	END_VAR
	VAR
		IO:				NH_PLC_DIR_IO;
	END_VAR
	VAR_TEMP
		ok1:				BOOL;		
//		mask: 			NH_PLC_DIR_MASK;
	END_VAR
	done	:= FALSE;
	CASE go OF
		0: RETURN;
		1:		// start list DIR with disk
				Go	:=	10; busy	:= TRUE;	errID	:= 0; IO.fPdir	:= 0; IO.fSdir	:= 0; nCyc := 0; tree:=TRUE;
				rb := memset(val := 0, length := SIZEOF(IO.lifeSize), dest := VOID( IO.lifeSize ));
				IF GoDelete THEN usr	:= 0;	END_IF;				// system DIR
				yTx0 := MID(dirName,1,1);	
				IF dirName = '' OR yTx0 <> '/' THEN										
					dirName := '//';															// root
				END_IF;
				yTx0	:= MID(dirName,1,LEN(dirName));									// last char in dirName for DIR/file
				IF	yTx0 <> '/' THEN													
					dirName := CONCAT(dirName,'/');										// add at the End DIR
				END_IF;
				rb := _NhSysLogMsg(msg:='->Start scan DIRs: {'+dirName+'}'); 
				// DIR log
				rb	:=	_Nh_Log_Path(wh:=24, frm:=3, wh2:=usr);	// yTx1	:=	'/RAM/USR/{usr}/PLC_DIR.log', if wh2:=0 '/RAM/SYS/PLC_DIR.log'
				IF _NhFdelete( fN:=yTx1, fH:=IO.hLsD, open:=TRUE, mode:=F_READ_PLUS  ) = FALSE THEN 
					errID	:=	2; yTx0 	:= CONCAT('IO.hLsD:{',yTx1,'}');
				END_IF;
				// FILES log
				IF GoDelete = FALSE 	THEN	rb	:=	_Nh_Log_PATH(wh:=24, frm:=4, wh2:=usr);	// list only all files		-> PLC_FILE.log		
				ELSIF testOnly 		THEN	rb	:=	_Nh_Log_PATH(wh:=24, frm:=5, wh2:=1);	// list of test-delete file 	-> TST_RRMM.log
				ELSE								rb	:=	_Nh_Log_PATH(wh:=24, frm:=5, wh2:=2);	// list of deleted filed 		-> DEL_RRMM.log
				END_IF;
				IF GoDelete AND append  THEN
					IF _NhFopen( fN:=yTx1, fH:=IO.hLsF, mode:=F_APPEND, close:=TRUE ) = FALSE THEN 
						errID	:=	2; yTx0 	:= CONCAT('append: IO.hLsF:{',yTx1,'}');
					END_IF;
				ELSIF _NhFdelete( fN:=yTx1, fH:=IO.hLsF, open:=TRUE, mode:=F_APPEND  ) = FALSE THEN 	// F_READ_PLUS
					errID	:=	2; yTx0 	:= CONCAT(yTx0,'delete: IO.hLsF:{',yTx1,'}');
				END_IF;
				IF errID > 0 THEN
					yTx0 := CONCAT(' Err: ',yTx0);
				ELSE
					yTx0	:= CONCAT('DELETED files from Root: {',dirName,'}'
										,'; lifeTime: ',UINT_TO_STRING(lifeTime)
										,' ; SubDir: ',BOOL_TO_STRINGF(noSubDir,'%b{N^Y}')
										,'; EmptyDir: ',BOOL_TO_STRINGF(emptyDir,'%b{Y^N}')
										,'; checkFile: ',BOOL_TO_STRINGF(checkFile,'%b{Y^N}')																				
										 );	
					rb	:=	_NhSysLogMsg(noIni:=FALSE, msg:=yTx0,openfH:=IO.hLsF, eRowBefore:=TRUE,eRowAfter:=TRUE,maxSize:=0);							
					_Nh_Dir_Data.dName		:= dirName;		
					_Nh_Dir_Data.dHed.dUp := 'R';													// sign for next cycle, that DIR pased	
					_Nh_PLC_DIR_Data_ADD( IO:=IO);	//, Name:=dirName );					// add 1.line to PLC_DIR.log
				END_IF;		

//				IO.hDir := INVALID_HANDLE_VALUE;


		10:	// read nex file/DIR or open new DIR 
				ok1	:= IO.hDir <> INVALID_HANDLE_VALUE;									// DIRs is open
				IF ok1 THEN
					ok1 := DirRead(hDir := IO.hDir, dirInfo := IO.Info);	   		// read next file/DIR
//					_Nh_Dir_Data.dHed.dUp := ' ';													// sign for next cycle, that DIR pased	
					IF ok1 THEN ;																	// ADD dir/file
					ELSIF noSubDir THEN															// End of DIR, No Search in Subdir
						Go	:= 99;																	// Go previous dir
						RETURN;
					ELSE																				// End of DIR
						rb := _NhFclose(fH:=IO.hDir, dir:=TRUE);
						Go	:= 12;																	// Go previous dir
						RETURN;
					END_IF;
				END_IF;
				IF ok1 = FALSE THEN
					IO.hDir	:= DirOpen( dirName := dirName, dirinfo:=IO.Info );
					IF IO.hDir = INVALID_HANDLE_VALUE THEN
						// Empty Dir - from 12-previous DID or from 3-start	
						IF IO.fPdir > 0 THEN
							IF tree=FALSE AND emptyDir THEN	
								IF 	FIND(dirName,aSys.YYYY_MM) > 0 THEN;				// actual mont DIRs '2025_05/'				
//								ELSIF FIND(dirName,'/SYS/') > 0 THEN;						// RAM/SYS/	
								ELSIF FIND(dirName,'/USR/') > 0 THEN;						// RAM/USR/*	
								ELSE
									rb	:=	_NhSysLogMsg(noIni:=TRUE,noTime:=TRUE,maxSize:=0,openfH:=IO.hLsF,
                                                msg:=dirName);
//									rb	:=	_NhSysLogMsg(ini:=0, msg:=' EMPTY-Dir: {'+dirName+'} fP:'+UDINT_TO_STRING(IO.fPdir));					
								END_IF;
							END_IF;		
							Go	:=	12;
//							RETURN;
						ELSE
							yTx0	:=	CONCAT('  ! Err: DirOpen {',dirName,'}; fN: {',IO.Info.fileName,'}');
							errID	:=	10; 					
						END_IF;		
					ELSIF tree = FALSE THEN	
//						rb := _NhFclose(fH:=IO.hDir, dir:=TRUE);
						Go	:=	12; 
//						RETURN;
					ELSE
						ok1	:=	TRUE;
					END_IF;
				END_IF
				IF ok1 THEN
					Go	:=	10;																							// next file in Dir
					yTx0 := MID(IO.Info.fileName,1,LEN(IO.Info.fileName));								// last char in dirName for check if DIR or file
					IF IO.info.fileName = '' THEN																// no file in new open DIR / unknown err
						ErrID := 10;
						yTx0 := 'IO.info.fileName=""';					
					ELSIF yTx0 = '/' THEN																				// is DIR
						ok1 := TRUE;
						IF 	IO.info.fileName = 'USB/' THEN	ok1 := aSys.DiskHed.disk[2].Exist;
						ELSIF IO.info.fileName = 'SDC/' THEN	ok1 := aSys.DiskHed.disk[3].Exist;
						ELSIF IO.info.fileName = 'RAM/' THEN	ok1 := aSys.DiskHed.disk[4].Exist;
						ELSIF GoDelete = FALSE 	THEN ; 																	// list writes all files
						ELSIF _Nh_Chk_Mask(what:=2, path:=IO.info.fileName) THEN	ok1 := FALSE;
						END_IF;
						IF ok1 THEN
							_Nh_Dir_Data.dName := CONCAT(dirName,IO.Info.fileName);
							rb := _Nh_PLC_DIR_Data_ADD( IO:=IO ); 				 								// OK: add new rec with DIR
						END_IF;
//					ELSIF false	THEN		// file													
					ELSIF checkFile	THEN		// file													
						ok1	:=	TRUE; 								// Write
						IF 	GoDelete = FALSE 	THEN	; 												// list writes all files
						ELSIF _Nh_Chk_Mask(what:=3, path:=dirName) THEN	ok1 := FALSE;
						END_IF;
						IF ok1 THEN
							_Nh_Dir_Data.fName	:= CONCAT(dirName,IO.info.fileName,_Nh_CRLF);
							IO.DaysOld := SUB_DT_DT_LONG(aSys.NhDT, IO.Info.modifyTime);

							IF IO.DaysOld.Days >= UINT_TO_DINT(LifeTime) THEN
								IO.lifeSize[0,0] := IO.lifeSize[0,0] + 1;
								IO.lifeSize[1,0] := IO.lifeSize[1,0] + IO.info.fileSize;
							ELSIF IO.DaysOld.Days >= UINT_TO_DINT(LifeTime/2) THEN
								IO.lifeSize[0,1] := IO.lifeSize[0,1] + 1;
								IO.lifeSize[1,1] := IO.lifeSize[1,1] + IO.info.fileSize;
							ELSIF IO.DaysOld.Days >= UINT_TO_DINT(LifeTime/4) THEN
								IO.lifeSize[0,2] := IO.lifeSize[0,2] + 1;
								IO.lifeSize[1,2] := IO.lifeSize[1,2] + IO.info.fileSize;
							ELSIF IO.DaysOld.Days >= 31 THEN
								IO.lifeSize[0,3] := IO.lifeSize[0,3] + 1;
								IO.lifeSize[1,3] := IO.lifeSize[1,3] + IO.info.fileSize;
							ELSE 
								IO.lifeSize[0,4] := IO.lifeSize[0,4] + 1;
								IO.lifeSize[1,4] := IO.lifeSize[1,4] + IO.info.fileSize;
							END_IF;

							_Nh_PLC_DIR_Data_ADD( IO:=IO, file:=TRUE );
						END_IF;
					END_IF;
				END_IF;

		12:	// Go Up to previous DIR
				IF IO.fPdir <= USINT_TO_UDINT(IO.lenRow) THEN										// 1.row i root = END
					IF tree THEN																				
						IF emptyDir THEN
							rb	:=	_NhSysLogMsg(noIni:=TRUE,openfH:=IO.hLsF,eRowBefore:=TRUE,eRowAfter:=TRUE,maxSize:=0,
                                          msg:='Deleted EMPTY DIRs:');							
						END_IF;
						IO.fPdir	:= IO.fSdir;
						tree		:= FALSE;																	// 2.cycle = check Empty DIRs
						Go := 12;
					ELSE
						Go	:=	99;
					END_IF;	
				ELSE
					IO.fPdir	:= IO.fPdir - USINT_TO_UDINT(IO.lenRow);					
					IF FileSetPos( hFile := IO.hLsD, offset := IO.fPdir) THEN					// previous (Up) Dir
						fRW	:=	FileRead(hFile:=IO.hLsD ,adrBuf:=PTR_TO_UDINT(ADR(_Nh_Dir_Data.dHed)),size:=USINT_TO_UDINT(IO.lenRow));
						dirName	:= _Nh_Dir_Data.dName;													// set Actual DIR for check file
						IF tree = FALSE THEN																	// 1.cycle = create DIR
							rb := _NhFclose(fH:=IO.hDir, dir:=TRUE);
							Go	:= 10;																			// Go next DIR (up  to file)
						ELSIF _Nh_Dir_Data.dHed.dUp <> ' ' THEN											// DIR has already been passed.
							Go	:= 12;																			// Go next DIR (up  to file)
						ELSIF FileSetPos( hFile := IO.hLsD, offset := IO.fPdir) THEN			// always=TRUE,  only to adjust begin row
							_Nh_Dir_Data.dHed.dUp := 'Y';													// sign for next cycle, that DIR pased	
							fRW	:=	FileWrite( hFile:=IO.hLsD ,adrBuf:=PTR_TO_UDINT(ADR(_Nh_Dir_Data.dHed)),size:=1 );					
							Go	:= 10;																			// next DIR
							IF FIND(dirName,'/.') > 0  THEN;												// Skip Hidden Dir-olny 
								Go := 12;
							END_IF;
						ELSE																			// unknown Err
							errID	:=	12; 											
							yTx0	:=	CONCAT('Unknown Err; fP:',UDINT_TO_STRING(IO.fPdir));
						END_IF;		
						rb := FileSetPos( hFile := IO.hLsD, offset := IO.fPdir);				// sets the position to the beginning of the line where DIR is loaded
					ELSE
						errID	:=	12; 
						yTx0	:=	CONCAT('Err-FileSetPos(fP)=FALSE: fP:',UDINT_TO_STRING(IO.fPdir));
					END_IF;							
				END_IF;


		90:	// Cancel
				errID := 90; 				// close files correctly
		99:	// END with error, OR no ERROR
				rb			:= _NhSysLogMsg(msg:='->End   scan DIRs. '+UINT_TO_STRING(nCyc)+' cyc');
				done		:=	TRUE;
				busy		:=	FALSE;
				dirName	:= '';
				rb 		:= _NhFclose(fH:=IO.hDir, dir:=TRUE);
				rb 		:= _NhFclose(fH:=IO.hLsD);
				rb 		:= _NhFclose(fH:=IO.hLsF);
				Go			:=	0;
				RETURN;
	ELSE		
		errID:=100;
		yTx0	:= CONCAT('No CASE Go:=',USINT_TO_STRINGF(Go,'%3u'));
	END_CASE;
	nCyc	:= nCyc + 1;	
	IF errID > 0 THEN
		Go	:=	99;
		ok1	:=	FALSE;
		ok2	:= TRUE;
		CASE errID OF
			1:		ok1	:= TRUE;		// open log-files
			10:	ok1	:= TRUE;		// open DIR
			90:	yTx0	:=	' *Cancel scan DIRs !';
		END_CASE;
		IF ok2 THEN	
			yTx0	:= CONCAT(' ! Err _Nh_PLC_DIR: ',USINT_TO_STRINGF(errID,'%03u')
									,' Msg: ',yTx0
									,';hDir: ',BOOL_TO_STRINGF(IO.hDir <> INVALID_HANDLE_VALUE,'%b{Y^N}')
									,';hLsD: ',BOOL_TO_STRINGF(IO.hLsD <> INVALID_HANDLE_VALUE,'%b{Y^N}')
									,';hLsF: ',BOOL_TO_STRINGF(IO.hLsF <> INVALID_HANDLE_VALUE,'%b{Y^N}')				
										);
		END_IF;
		IF ok1 THEN
				rb		:=	GetLastErrTxt(errCode:=GetLastErr(), errMessage := yTx2);
				yTx0	:= CONCAT(yTx0,';GetErr: ',yTx2);
		END_IF;
		rb := _NhSysLogMsg(msg:=yTx0);
	END_IF;
END_FUNCTION_BLOCK

VAR_GLOBAL
	fb_Nh_PLC_DIR		: _Nh_PLC_DIR;
END_VAR



FUNCTION _Nh_LVL_100 {HIDDEN}: REAL // vypocita LVL 0..100 a koriguje o Minimum a Maximu
   VAR_INPUT
 		lvlIn: REAL; 	// hodnota 0..100
   	lvlMin: USINT := 10; 	// minimum 0..100
   	lvlMax: USINT := 100; // maximum 0..100
   END_VAR
   _Nh_LVL_100 := ( USINT_TO_REAL(lvlMin) + lvlIn * ( USINT_TO_REAL(lvlMax - lvlMin) / 100.0 )) * BOOL_TO_REAL(lvlIn > 0.0) ; // minimum + skorigovany LVL

// _Nh_LVL_100 := USINT_TO_REAL(lMin) + LVL*( USINT_TO_REAL(lMax-lMin)/254.0 ); // minimum + skorigovany LVL
// _Nh_LVL_100 := _Nh_LVL_100/2.54 * BOOL_TO_REAL(LVL > 0.0); // prevod na 0..100 len ked je VAL > 0
//	_Nh_LVL_100	:= ( vr + xDev^.al.ou.val * (kr - vr) / 100.0) * BOOL_TO_REAL(xDev^.al.ou.val > 0.0) ;
END_FUNCTION

FUNCTION _Nh_255_100 {HIDDEN}: REAL
   VAR_INPUT
      lvl: USINT;
   END_VAR
// _Nh_255_100 := FLOOR( USINT_TO_REAL(LVL)/2.54 );
   _Nh_255_100 := USINT_TO_REAL(LVL);
END_FUNCTION

FUNCTION_BLOCK _Nh_PWM {HIDDEN} // Blikac / Pulsne sirkova modulace
   VAR_INPUT
      Per: UINT; // perioda modulace [ms] (50-56000)
      Pls: USINT; // sirka pulsu [%] (0-100% z periody)
      Run: BOOL; // povolovaci vstup
   END_VAR
   VAR_OUTPUT
      Q: BOOL; // priznak zmeny vystupu
      Out: BOOL; // vystup
      et: UINT; // zostavajuci cas do konca periody [ms]
   END_VAR
   VAR
   END_VAR
   Q := FALSE;
   IF Run = FALSE THEN // je spusteny blikac
      et := 0;
      IF Out THEN // ak prisiel stop (run=0) v priebehu trvania impulzu, vystup mohol byt zapnuty
         Out := FALSE; // finalne vypne vystup
         Q := TRUE;
      END_IF;
   ELSIF et = 0 THEN // start
      et := MAX(50, Per);
      IF pls > 0 THEN // zapne sa len ked ma nejake trvanie
         Out := TRUE;
         Q := TRUE;
      END_IF;
   ELSE
      et := et - MIN(et, aSys.mSec);
      IF et > 0 AND Out AND pls < 100 THEN
         IF et <= REAL_TO_UINT( UINT_TO_REAL(per) * 0.01 * USINT_TO_REAL(100 - pls)) THEN // zostavanic cas je meni ako doba vypnutia (100-pls)
            Out := FALSE;
            Q := TRUE;
         END_IF;
      END_IF;
   END_IF;
END_FUNCTION_BLOCK


FUNCTION_BLOCK _Nh_Blik_FB {HIDDEN}
	VAR_INPUT
		wht: USINT;				// perioda
      nbr: USINT; // pocet zablikani
		RunOn: BOOL; // zapnut
		// future
//		RunOff: BOOL;
//		EndOn: BOOL;
//		EndOFF: BOOL;
   END_VAR
   VAR_OUTPUT
      Q: BOOL; // vystup
      Qi: BOOL; // zmena ON-OFF-ON
		Qn: BOOL; 		// imp. pri dosiahnuti poctu zaplikani
   END_VAR
   VAR
// Qr: BOOL;
      Qo: BOOL;
   END_VAR
	CASE wht OF
   	 0: Q	:= 0;
				RETURN;
		 1: Q := SYSTEM_S.PERIOD_PULSE_1SEC;					// kazdu sec
		 2: Q := SYSTEM_S.PERIOD_PULSE_10SEC;					// kazdych 10S pravidelne
		 3: IF Q THEN													// 10s je zapmute a 1s vypnute
					IF SYSTEM_S.R_EDGE_10SEC THEN
					 Q := FALSE;
					END_IF;
	 			ELSIF SYSTEM_S.R_EDGE_1SEC THEN
					Q := TRUE;
		 		END_IF;
		 5: Q := SYSTEM_S.PERIOD_PULSE_500MS;					// kazdych 500ms
		 6: Q := SYSTEM_S.PERIOD_PULSE_1MIN;					// kazdu 1.Min
				// vlastne pulzy
		100: Q := aSys.PULSE_50MS;
		101: Q := aSys.PULSE_100MS;
		102: Q := aSys.PULSE_200MS;
	END_CASE;
   Qi := Q <> Qo;
   Qo := Q;
	Qn	:= FALSE;

	IF nbr = 0 THEN
		;
	ELSIF RunON THEN
		IF	Q THEN
			RunOn 	:= FALSE;
			Qi		 	:= TRUE;
		END_IF;
	ELSIF	Qi AND Q = FALSE THEN
		nbr 	:= nbr - 1;
		IF nbr = 0 THEN
			Qn		:= TRUE;
			wht 	:= 0 ;
		END_IF;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK _Nh_Click_FB {HIDDEN}

   VAR_OUTPUT
		Q: BOOL; // vyhodnotenie {impulz alebo ak je press alebo hold, je signal az do ukoncenia)
		Qb: BOOL;										// ak bol pri vyhodnocovani jedenehi BTN stlaceny INY BTN
		Lock: BOOL;										// WSB je zalokovane = drzi sa viac ako 10s
		Click: USINT; 	// cislo clicku na OutBTN
		OutBtn: USINT; 	// vyhodnoteny btn = InBtn pri prvom stlaceni
	END_VAR
	VAR_INPUT
		InBtn: USINT; 				// stalceny nejaky btn v sekcii CLICK ... trva asi 8 cyklov, potom 0->1
      cfc: PTR_TO NH_CFG_CLICK; 				// zaciatok CFX je rovnaky pre vsetky
		BTNs: USINT := 6;
	END_VAR
 	VAR
		trg: aTrgQx;											// vyhodnoti Qr,Q,Qf
		tClk: DT;													// strojovy cas clicku
   	Go: USINT;
		et: USINT;
	END_VAR
	Q			:= FALSE;
	Qb			:= FALSE;
	Lock		:= FALSE;
	IF trg.Qr	THEN
		IF InBtn > 0 THEN
			i			:= InBtn;
		ELSE
			FOR i := 1 TO BTNs DO
				IF xPtB^ THEN
					EXIT;
				END_IF;
				xPtB := xPtB + 1;
   		END_FOR;
		END_IF;
		IF Go = 8 THEN
			IF i <> OutBtn THEN
				xDevOkA^.al.ou.cmd	:= OutBtn;
				xDevOkA^.al.ou.par	:= USINT_TO_INT(Click);
				Qb						:= TRUE;
				Click 				:= 0;
			END_IF;
		ELSE
			Click 				:= 0;
		END_IF;
		Go 					:= 9; 										// startuje sa vzdy 1
		OutBtn				:= i;
		tClk					:= GetRTC();									// zaciatok Clicku

//		_Nh_Log_Evn_ADD( tsk := aCfg[cf].tgrp, wht := 'BEG', tRtc := tClk);

		xDevOkA^.al.ou.Val := USINT_TO_REAL(i);
		xDevOkA^.ok.ref	:= TRUE;
		xDevOkA^.al.sta	:= 1;
	ELSIF trg.Q	THEN
		_NhTime := SUB_DT_DT( GetRTC() , tClk);
		IF _NhTime > T#11s THEN
			Lock 	:= TRUE;
			Go		:= 0;
		ELSE
			CASE Go OF
   	 0: // uz sa vyhodnotil Hold, alebo aj press pred Hold, caka sa len na pustenie BTN
      	 1: // prebieha press - posielaju sa udaje pre stmievanie ....
					Q	:= TRUE;
			 2:	// bezi cakacka na Hold - kedy sa dosiahne cas;
					IF SUB_DT_DT( GetRTC() , tClk) > USINT_TO_TIME(cfc^.Hold) * 100 THEN								// HW vyhodnotil Click, mal by byt na to BTN, ktory je prve spracovavany
						Click := 7;
						Q			:= TRUE;
						Go 		:= 0;
					END_IF;
	 	ELSE
				IF _NhTime >= USINT_TO_TIME(cfc^.Press) * 100 THEN // prvykrat sa dosiahol press
					IF cfc^.Press > 0 THEN // prvykrat sa dosiahol press
						Click := 6;
						Q			:= TRUE;
					END_IF;
					IF cfc^.Hold > 0 THEN // AND cfC^.BtnHold[Btn] // kontrola, ci nie je nadefinovany Hold
      	 	Go 	:= 2;
					ELSE
						Go		:= 1;
					END_IF;
   	 END_IF;
			END_CASE;
		END_IF;
	ELSIF trg.Qf	THEN
		IF Go = 9 THEN													// prve pustenie btn
			Click := Click + 1;
			IF Click > 4 THEN										// dosakol sa MAX pocet 5-Clickov
				Q 				:= TRUE;
				Go 			:= 0;
			ELSIF cfc^.Click = 0 OR cfc^.OneClck[OutBtn] THEN	// btn NE-bude vyhodnocovat dalsi click, potvrdi sa prvy
				Q 				:= TRUE;
				Go 			:= 0;
			ELSE
				tClk	:= GetRTC();									// zaciatok Clicku
				Go 	:= 8;
         END_IF;
			et := 20;
		ELSE 													// prebieha press alebo Hold
			et := 5;
			Go 	:= 0;
		END_IF;
	ELSIF Go = 8	THEN // cakacka na dalsi click
		IF SUB_DT_DT( GetRTC() , tClk) > USINT_TO_TIME(cfc^.Click) * 100 THEN								// HW vyhodnotil Click, mal by byt na to BTN, ktory je prve spracovavany
			Q				:= TRUE;
			Go 			:= 0;
		END_IF;
	ELSIF et > 0 THEN
		IF SYSTEM_S.R_EDGE_100MS THEN
			et := et - 1;
			IF et = 0 THEN
				xDevOkA^.al.ou.val 	:= 0.0;
				xDevOkA^.ok.ref		:= TRUE;
				xDevOkA^.al.sta		:= 0;
			END_IF;
		END_IF;
	END_IF;
	IF Q THEN
		xDevOkA^.al.ou.cmd	:= OutBtn;
		xDevOkA^.al.ou.par	:= USINT_TO_INT(Click);
	ELSIF Qb = FALSE THEN
		xDevOkA^.al.ou.cmd	:= 0;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION _Nh_Go_MemToDBX    : BOOL    		// ulozi do dbx celu RAM alebo len DBX
	VAR_INPUT
		DBX	: BOOL;
	END_VAR
	IF DBX OR aSys.UseRBx = false THEN
	   _Nh_Go_MemToDBX	:= WriteToDBx( dataBoxAddress := aDbx.ver.Dbx0, length := MIN(aSys.Size_DBx,aDbx.vRam), varAddress := PTR_TO_UDINT(ADR(mRam)) ) ;		
	   aSys.nMemToDbx    := aSys.nMemToDbx + 1;
	ELSE //aSys.UseRBxTHEN
   	_Nh_Go_MemToDBX	:= WriteToRBx ( ramBoxAddress := aDbx.ver.Dbx0, length := aDbx.vRam, varAddress := PTR_TO_UDINT(ADR(mRam)) ) ;
	   aSys.nMemToRBx    := aSys.nMemToRBx + 1;
	END_IF;
   aSys.CfgDbxOk  	:= true;
   aSys.UpdDbx      	:= 0;
END_FUNCTION

FUNCTION _Nh_Create_DIR_PATH: BOOL // check OR create DIR in the entire path
	VAR_INPUT
		noLog:	BOOL; 	// log result to system log 
      disk:    USINT;   // 1=NH2,2=USB,3=SDC,4=RAM
		wh:      USINT; 	// 21=NH2,22=USB,23=SDC,24=RAM
		wh2:    	USINT; 	// additional parameter
		frm:     UINT; 	
	END_VAR

	VAR_TEMP
      create :   BOOL; 
		i: USINT;
	END_VAR
	rb		:= _Nh_Log_Path(wh:=wh, frm:=frm, wh2:=wh2);											// path to yTx1
	yTxA	:= yTx1;																		// _Nh1RowTxt replace yTx1, yTxA maps  to free mem

	IF FileExists( fileName := yTxA) THEN
      _Nh_Create_DIR_PATH  := TRUE;
	ELSIF CPU_CODE >= 2000 THEN																// CP-2000 create DIR in one step
//	ELSIF FALSE THEN																		
		_Nh_Create_DIR_PATH  := ForceDirs(fileName := yTxA);
		create               := true;																		// exist
	ELSE																					// CP-1000 must create DIR step by step
		create               := true;																		// exist
 		_Nh_Create_DIR_PATH  := TRUE;		
		yTxC	:= '';																		// postupne sa bude skladat cesta
		FOR i := 1 TO LEN( yTxA ) DO
		 	yTxB	:= MID( yTxA, 1, i );													// extract	next char
			yTxC	:= CONCAT( yTxC, yTxB );												// ads next char
		 	IF yTxB = '/' THEN 																// ebd of dir
				IF FileExists( fileName := yTxC) THEN										// test if exist
					;
				ELSIF DirCreate( dirName := yTxC ) = FALSE THEN								// create dir universal method CP1000 and CP2000
					_Nh_Create_DIR_PATH := FALSE;
					EXIT;
				END_IF
			END_IF;
		END_FOR;
		yTxA := yTxC;
	END_IF;
	IF _Nh_Create_DIR_PATH = FALSE THEN
		aSys.DiskHed.Disk[disk].errCrDir	:= GetLastErrTxt(errCode := GetLastErr(), errMessage := yTx2);
		yTx2	:= CONCAT(USINT_TO_STRING(disk), ' Err Create DIR: ',yTxC, ' of ',yTxA, ' Err: ', yTx2);
//		rb:=_NhSysLogMsg(msg:=yTx2);
//	 	rb		:= _Nh1RowTxt(logRst := 1, adTime := 3);
   ELSIF create THEN
		yTx2	:= CONCAT(USINT_TO_STRING(disk), ' Create DIR  Ok: ',yTxA );
   ELSE
//		yTx2	:= CONCAT(USINT_TO_STRING(disk), ' Test DIR    Ok: ',yTxA );
		NoLog	:= TRUE;
	END_IF;
	rb:=_NhSysLogMsg(NoTime:=TRUE, NoLog:=NoLog,msg:=yTx2);
//	rb		:= _Nh1RowTxt(logRst := 1, adTime := 3);
END_FUNCTION

FUNCTION_BLOCK _Nh_Create_DIR  // Check disks/space/DIRs,create DIRs in the entire path. At specied Hour o Manualy start Clean disks space
	VAR_INPUT
		exec:   			BOOL; 			//  start new check disks/space/DIRs and create DIRs in the entire path
		err:   			BOOL; 			//  start new check disks/space/DIRs and create DIRs in the entire path
		refrClean:		BOOL;
	END_VAR
	aSys.DiskHed.USB_Ready(In:=SYSTEM_S.USB_DISK_READY);
//	refrClean	:= aSys.Restart;
	CASE aSys.Ini OF
		0: 	// normal RUN
				IF aSys.DiskHed.USB_Ready.Qx  THEN
			 		IF aSys.DiskHed.USB_Ready.Qr THEN
   					yTx2 	:= 'USB Inserted';													// START Create Dir
		        ELSE
   					yTx2 	:= 'USB REmoved';													// START Create Dir
	 				END_IF;
					rb:=_NhSysLogMsg(msg:=yTx2+' !!! Re-Create Dir..');
//					IF fb_Nh_Copy_Dir.busy = FALSE THEN
						exec	:= true;
	//				END_IF;
				END_IF;
				IF aSys.F_EDGE_1HOUR THEN
					IF SYSTEM_S.COUNTER_HOURS = aSys.DiskHed.HourClean  THEN
						FOR i:=1 TO 4 DO
							
						END_FOR;
						exec			:= TRUE;															// check disks space
					  	rb	:=	_NhSysLogMsg(msg:='+ Start ALL Disk Clean');
					END_IF
				END_IF;
	END_CASE;
	IF exec  THEN												// start
      err		:= FALSE;
      exec     := FALSE;
   	_NhDT    := GetRTC();      
		aSys.DiskHed.Disk[1].path	:= '/';							// native PLC journaled disk ''= for diskinfo
		aSys.DiskHed.Disk[2].path	:= 'USB/';						// externeal insert/remove
		aSys.DiskHed.Disk[3].path	:= 'SDC/';						// internal 
		aSys.DiskHed.Disk[4].path	:= 'RAM/';						// internal FOXTROT-2
      FOR i := 1 TO 4 DO
         rb	:= DiskInfo(diskName          := aSys.DiskHed.Disk[i].path, diskDesc := aSys.DiskHed.Disk[i].info); // bytes
         aSys.DiskHed.Disk[i].errCrDir    := FALSE;      
			aSys.DiskHed.Disk[i].Exist       := aSys.DiskHed.disk[i].Info.TotalNumberOfKBytes > 0;
         aSys.DiskHed.Disk[i].freeSpace   := 0;    
         IF aSys.DiskHed.Disk[i].Exist THEN
   			aSys.DiskHed.Disk[i].freeSpace   := REAL_TO_USINT( 100.0 * 
                                                               UDINT_TO_REAL(aSys.DiskHed.disk[i].Info.TotalNumberOfFreeKBytes) / 
                                                               UDINT_TO_REAL(aSys.DiskHed.disk[i].Info.TotalNumberOfKBytes) ); 
			END_IF;
      END_FOR;
      // base dir NH2/ od native journaled disk
		IF true THEN
			aSys.DiskHed.Disk[1].path	:= 'NH2/';
			err := _Nh_Create_DIR_PATH( disk:=1, wh := 21, frm := 1,NoLog:=refrClean) = FALSE; 
				//	aSys.DiskHed.Disk[3].Exist :=false;
			// test if exist real USB/ next substitute USB/ to SDC/ or NH2/

aSys.DiskHed.Disk[3].Exist:=FALSE; //XXX disable SDC check

   	   IF aSys.DiskHed.Disk[2].Exist THEN													// OK : disk USB ready inserted
      	   ;
	      ELSIF aSys.DiskHed.Disk[3].Exist THEN
   	      aSys.DiskHed.disk[2]       := aSys.DiskHed.disk[3];      				// link USB = SDC
      	   aSys.DiskHed.Disk[2].Exist := FALSE;
	      ELSE 
   	      aSys.DiskHed.disk[2]       := aSys.DiskHed.disk[1];      				// link USB = SYS
      	   aSys.DiskHed.Disk[2].Exist := FALSE;
	      END_IF
   	   // create DBX dir
			err := err OR _Nh_Create_DIR_PATH(wh:=22, disk:=2, frm:=1, NoLog:=refrClean) = FALSE;	// log dirs
   	   // create all LOG dirs
			FOR i := 1 TO 4 DO															
				err := err OR _Nh_Create_DIR_PATH(wh:=22, disk:=2, frm:=2, wh2:=i, NoLog:=refrClean) = FALSE;	// log dirs
			END_FOR;
	      // test if exist real SDC/
   	   IF aSys.DiskHed.Disk[3].Exist = false THEN
      	   aSys.DiskHed.disk[3]       := aSys.DiskHed.disk[1];
				aSys.DiskHed.Disk[3].Exist	:= false;
			END_IF;	
//			err := err OR _Nh_Create_DIR_PATH(wh:=23, disk:=3, frm:=1, NoLog:=refrClean) = FALSE;
      	IF aSys.DiskHed.Disk[4].Exist = false THEN
         	aSys.DiskHed.disk[4]       := aSys.DiskHed.disk[1];
				aSys.DiskHed.Disk[4].path 	:= CONCAT(aSys.DiskHed.disk[4].path, _NH2_VER, '/');	// if not exist, then substitute to NH2/200/.  only for FRM/	
				aSys.DiskHed.Disk[4].Exist	:= false;
			END_IF;	
			// RAM disk  
			err := err OR _Nh_Create_DIR_PATH(wh:=24, disk := 4, frm:=1, NoLog:=refrClean) = FALSE;	// FRM dir
			// create all RAM/USR/xx dirs, 00=SYS,01..09=USR
			FOR i := 0 TO 9 DO															
				err := err OR _Nh_Create_DIR_PATH(wh:=24, disk:=4, frm:=2, wh2:=i, NoLog:=TRUE) = FALSE; 								
			END_FOR;
			aSys.DiskHed.timeExec   := TIME_TO_UINT ( SUB_DT_DT( GetRTC() , _NhDT ) );
		END_IF;
      FOR i := 1 TO 4 DO
         IF aSys.DiskHed.Disk[i].Exist THEN
				IF aSys.DiskHed.Disk[i].freeSpace < aSys.DiskHed.Disk[i].minSpace THEN
				  	rb:=_NhSysLogMsg(noIni:=TRUE,
											msg:='! Disk: '
					  								+ USINT_TO_STRING(i)  + ' '					  								
													+ aSys.DiskHed.Disk[i].path + ' Low space: '
					  								+ USINT_TO_STRING(aSys.DiskHed.Disk[i].freeSpace)  + ' % of '
					  								+ USINT_TO_STRING(aSys.DiskHed.Disk[i].minSpace)   + ' % ; '													
					  								+ UDINT_TO_STRING(aSys.DiskHed.disk[i].Info.TotalNumberOfFreeKBytes/1024)  + ' MB of '
												  	+ UDINT_TO_STRING(aSys.DiskHed.disk[i].Info.TotalNumberOfKBytes/1024 )		+ ' MB');						
//					BusyClean			:= TRUE;													// alow Run Clean
					aSys.DiskHed.Disk[i].GoClean 	:= TRUE;      							// set request for disk Clear
				END_IF;
         END_IF
      END_FOR;
	END_IF;
END_FUNCTION_BLOCK


FUNCTION_BLOCK _Nh_Backup		// backup MEM/RAM/DBX -> File or Restore File -> MEM/RAM/DBX
	VAR_INPUT
      go :			USINT;
//		goWeb :		USINT;
		IniEnd : 	USINT:=255;
		IniErr : 	USINT:=255;
		IniRun : 	USINT:=255;	
	END_VAR                        	
	VAR_OUTPUT
		cyc : 		UINT;
	END_VAR
	VAR
		fbRW		   : _Nh_File_RW;
      logTxt      : STRING[3];
	END_VAR
	CASE go OF
		0:		IF aSys.UpdFile < 100 THEN						// save MEM->RBx->file
      			RETURN;
				END_IF;
				IF go > 0 THEN	;							// goWeb	priority
				ELSIF aSys.UpdFile > 253 THEN			
					IF aSys.UpdFile = 254 THEN			// save MEM->RBx->file
						go := 10;
					END_IF;
					IF aSys.UseRBx THEN
						go := go + 2;								// RBx -> file
					ELSIF aSys.IS_DBX THEN 		
						go := go + 3;
					ELSE
						go := go + 1;
					END_IF;
				END_IF;	
				_NhOulog(msg:='-> start ',io:=io);
		100:	// run
				fbRW(); 
				IF fbRW.io.done THEN
					Go 			:= 0;	
			  		aSys.Ini		:= IniEnd;
      			IF fbRW.io.err THEN
						rb			:=_NhSysLogMsg(msg:='! Err: '+yTx0); 			// _Nh_File_RW leave message in yTx0
			   		aSys.Ini	:= IniErr;
						RETURN;
					ELSIF fbRW.full = FALSE THEN
						rb := _Nh_Log_Path(wh:=21, frm:=3);							// rename dbx.wrk -> dbx.mem, and load actual backup into yTx2 from dbx.mem
			 			yTx2 	:= CONCAT('New Bakup {',logTxt,'}->{',yTx2,'}' );
					ELSE
						rb 	:= _Nh_Log_Path(wh:=21, frm:=2);						// read path from dbx.mem to yTx2
 						yTx2 	:= CONCAT('Restore {',yTx2,'}->{',logTxt,'}' );
					END_IF;
					rb:=_NhSysLogMsg(msg:='->'+yTx2+' sz:{'+UDINT_TO_STRING(fbRW.io.actSize)+'}'); //,cyc:'+UINT_TO_STRING(cycleCnt));
				END_IF;
				RETURN;
	   200:  RETURN;
      201:  RETURN;
      202:  RETURN;
      203:  RETURN;
//	ELSE 		go := 0; RETURN;
	END_CASE;
	fbRW.io 				:= _eIoBusy; 
	cyc 					:= 1;		
	aSys.UpdFile 		:= 0;
   aSys.Ini				:= IniRun;
	fbRW.io.reqSize 	:= aDbx.vRam;
	fbRW.io.go 			:= go;
	IF go > 10 THEN
			go := go - 10;
			fbRW.full := FALSE;   // write -> file
	ELSE
			fbRW.full := TRUE;   // write -> file
	END_IF;		
	CASE go OF
		1:	logTxt := 'MEM'; fbRW.aVar	:= PTR_TO_UDINT(ADR(mRam)); 
		2:	logTxt := 'RBx'; fbRW.aVar	:= PTR_TO_UDINT(ADR(aDbx.ver.Dbx0));	// <-> file	 
		3:	logTxt := 'DBx'; fbRW.aVar	:= PTR_TO_UDINT(ADR(aDbx.ver.Dbx0));	// <-> file	 
	END_CASE;
   fbRW.line   := FALSE;
   go 	:= 100;
	IF fbRW.full = FALSE THEN					 			// -> write file
      rb 	:=_Nh_Log_Path(wh:=22, frm:=1, wh2:=2);
		yTx0 	:= CONCAT('{',yTx1,'}{',yTx2,'}');
		IF rb THEN // yTx1 := 'dbx.wrk'; yTx2:='NH2/V21//DBX/YYYY_MM/DD_hhmm.DBX' (yTx2->dbx.wrk)
 			rb		:=_NhSysLogMsg(msg:='2.Rbx->file: '+yTx0,debug:=true);
         yTx0  := yTx2;
         fbRW();
		ELSE
   		rb		:= _Nh_Ou_Err(io:=fbRW.io, msg:=yTx0, errTyp:=2, ErrID:=1010);
         go 	:= 201;
		END_IF;				
	ELSE
      rb := _Nh_Log_Path(wh:=21, frm:=2);  // ytx1:='dbx.NH2' -> load last backup file from dbx.NH2 -> into yTx2
		yTx0 	:= CONCAT('{',yTx1,'}{',yTx2,'}');
		IF rb THEN
   		rb	   :=_NhSysLogMsg(msg:='3.file->RBx: '+yTx0,debug:=true);
			yTx0 := yTx2;
         fbRW();
   	ELSE
   		rb		:= _Nh_Ou_Err(io:=fbRW.io, msg:=yTx0, errTyp:=2, ErrID:=1011);
         go 	:= 202;
      END_IF;
   END_IF;
END_FUNCTION_BLOCK



(*
FUNCTION_BLOCK _Nh_Cfg_Backup		// backup MEM/RAM/DBX -> File or Restore File -> MEM/RAM/DBX
	VAR_INPUT
      Go :			USINT;
      write :     BOOL;
		IniEnd		: USINT;
		IniErr		: USINT;
		IniRun		: USINT;	
//		logRst		: BOOL:=TRUE;		// loguje akciu do _NhRest,LOG
	END_VAR                        	
	VAR
		fbRW		   : _Nh_File_RW;
      logTxt      : STRING[3];
	END_VAR
//	done	:= false;		
	CASE Go OF
		0:		IF aSys.UpdFile < 100 THEN						// save MEM->RBx->file
					;
				ELSIF aSys.UseRBx THEN
					Go := 2; write := TRUE; 
				ELSIF aSys.IS_DBX THEN 		
					Go := 3; write := TRUE;
				ELSE ;
				END_IF;	
				RETURN;

		1:		go:= 1; fbRW.full := TRUE;
		11:	go:= 1; fbRW.full := FALSE;
		2:		go:= 2; fbRW.full := TRUE;
		12:	go:= 2; fbRW.full := FALSE;

		100: ;
	// start
	fbRW.io := _eIoBusy; 
	fbRW.io.reqSize := aDbx.vRam;
	CASE go OF
		0: 
		1:	logTxt := 'MEM'; fbRW.aVar	:= PTR_TO_UDINT(ADR(mRam)); 
		2:	logTxt := 'RBx'; fbRW.aVar	:= PTR_TO_UDINT(ADR(aDbx.ver.Dbx0));	// <-> file	 
		3:	logTxt := 'DBx'; fbRW.aVar	:= PTR_TO_UDINT(ADR(aDbx.ver.Dbx0));	// <-> file	 
	ELSE
		
	END_CASE;
	
	
	
	go := 100;


		1:		logTxt 		:= 'MEM';
            fbRW.io 		:= _eIoBusy;
            fbRW.aVar	:= PTR_TO_UDINT(ADR(mRam)); 				// <-> file	
            IF write THEN	// -> file
               fbRW.io.reqSize	:= aDbx.vRam;
            END_IF;

		2:		logTxt 		:= 'RBx';
            fbRW.io 		:= _eIoBusy;
            fbRW.aVar	:= PTR_TO_UDINT(ADR(aDbx.ver.Dbx0));	// <-> file	
            IF write THEN	// -> file
           		rb 					:= _Nh_Go_MemToDBX();
               fbRW.io.reqSize	:= aDbx.vRam;
            END_IF;

		3:		logTxt 		:= 'DBx';
            fbRW.io 		:= _eIoBusy;
            fbRW.aVar	:= PTR_TO_UDINT(ADR(aDbx.ver.Dbx0));	// <-> file	
            IF write THEN	// -> file
           		rb 					:= _Nh_Go_MemToDBX(dbx:=TRUE);
               fbRW.io.reqSize	:= MIN(aSys.Size_DBx, aDbx.vRam);
            END_IF;
		100:	// busy
		101:	// busy
		103:	// err
   ELSE	   go:=0;
            RETURN;
	END_CASE;
	IF Go < 20 THEN 							//

		aSys.UpdFile := 0;
   	aSys.Ini		:= IniRun;



	IF Go < 20 THEN 							//
		aSys.UpdFile := 0;
   	aSys.Ini		:= IniRun;
      fbRW.io.go  := go;
      fbRW.line   := FALSE;
		IF write THEN					 						// -> write file
			fbRW.io.mode := F_WRITE;
			IF _Nh_Log_Path(wh:=22, frm:=1, wh2:=2) THEN 	// insert path to yTx2 + suffix and write to dbx.wrk {'NH2/002/2025_01/25_1030.DBX' -> dbx.wrk}
 				rb		:=_NhSysLogMsg(msg:='2.Rbx->file: {'+yTx1+'}{'+yTx2+'}',debug:=true);
				yTx1	:=yTx2;																	// yTx1:='dbx.wrk', yTx2:=full path
            write := TRUE;
				Go		:= 100;
            fbRW(fN:=yTx2,full:=FALSE);
//				fbRW.io.exec:=1; fbRW.mode:=1; fbRW.allFile:=0; fbRW.Line:=0;
			ELSE
	 			rb		:=_NhSysLogMsg(msg:='FALSE: Write to:  {'+yTx1+'}{'+yTx2+'}',debug:=true);
				Go		:= 101;
			END_IF;				
		ELSIF	_Nh_Log_Path(wh:=21, frm:=2) THEN									// load last backup file from dbx.mem into yTx2
			rb	   :=_NhSysLogMsg(msg:='TRUE : Read from: {'+yTx1+'}{'+yTx2+'}',debug:=true);
         fbRW(fN:=yTx1,full:=TRUE);
//			fbRW.io.exec:=1; fbRW.mode:=0; fbRW.allFile:=1; fbRW.Line:=0;;
		ELSE
			rb:=_NhSysLogMsg(msg:='FALSE: Read from: {'+yTx1+'}{'+yTx2+'}',debug:=true);
			Go		:= 103;
         fbRW.io.busy := FALSE; fbRW.io.done := TRUE;
		END_IF;
	END_IF;

	fbRW(fN:=yTx1);		

//	cyc := cyc + 1;	

   IF fbRW.io.done THEN
  		aSys.Ini			:= IniEnd;
      IF fbRW.io.errID > 0 THEN
   		aSys.Ini	:= IniErr;
		ELSIF write THEN
			rb := _Nh_Log_Path(wh:=21, frm:=3);							// rename dbx.wrk -> dbx.mem, and load actual backup into yTx2 from dbx.mem
 			yTx2 	:= CONCAT('New Bakup {',logTxt,'}->{',yTx2,'}' );
		ELSE
			rb 	:= _Nh_Log_Path(wh:=21, frm:=2);						// read path from dbx.mem to yTx2
 			yTx2 	:= CONCAT('Restore {',yTx2,'}->{',logTxt,'}' );
		END_IF;
//		IF logRst THEN
			rb:=_NhSysLogMsg(msg:='->'+yTx2+' sz:{'+UDINT_TO_STRING(fbRW.io.actSize)+'}'); //,cyc:'+UINT_TO_STRING(cycleCnt));
//		END_IF;	
		Go := 0;
	END_IF;
END_FUNCTION_BLOCK


*)

FUNCTION_BLOCK _Nh_Copy_DIR // copy file or directory
	VAR_INPUT
		go: 		   USINT;			// 1=copy file, 2=copy dir and next case run 
		srcName :	STRING;			// source DIR or fileName
		dstName :	STRING;			// destination DIR or fileName 
		seek :		UDINT;			// from start position in source file
		file : 		BOOL;				// frag for file (TRUE) or DIR (FALSE)
		append :		BOOL;				// apped to destinantion file
		delFile : 	BOOL;			   // delete after copy (move)
		delDir:		BOOL;
	END_VAR
   VAR_OUTPUT
		io :			NH_IO_BUSY;		// IO standard variable
      cyc :       UINT;				// heere is cyc, (not used io.cyc)
		allSize : 	UDINT;			// total bytes
		files : 		UINT;				// total files
		fi : 			TFileInfo;		// structure for DIRread (info file)
   END_VAR
   VAR
		hDir : 		HANDLE;			// source DIR
      hSrc : 		HANDLE;			// source file (from DIR)
      hDst : 		HANDLE;			// dest file	
      hLog : 		HANDLE;			// log file
   END_VAR
	io.done	:= FALSE;
	CASE Go OF
     	0: 	RETURN;

     	1: 	// copy file
				// ytx3,yTx4 contain both source and destination files, including the path
				file := TRUE; io := _eIOBusy; io.init:=TRUE; // ou: busy,exec,init := TRUE;
				yTxC := 'File';
	  	2: 	// Start copy DIR + first file
				yTxC := 'Files from DIR';
				IF delDir THEN yTxC := CONCAT(yTxC,'. DIR wil be Deleted'); END_IF;
				file := FALSE; io := _eIOBusy; io.init:=TRUE;	
				hDir	:= DirOpen(dirName := srcName, dirInfo := fi);           		// open DIR for read
				IF hDir = INVALID_HANDLE_VALUE THEN                                  // open DIR error
					rb	:= _Nh_Ou_Err(io:=io, msg:=': {'+yTx1+'}', errTyp:=2, ErrID:=1009);	
				END_IF;
    	
		10: 	;// copying 1 solo file
    	12: 	;// copying 1 file from DIR

    	22: 	// Next file in copy DIR
				IF DirRead(hDir := hDir, dirInfo := fi)  THEN
					io := _eIOBusy;	
				ELSE		
					io.done := TRUE; io.exec := FALSE; io.busy := FALSE; io.found:=0;
				END_IF;
	ELSE 		// bad command
				Go := 0;
				RETURN;
	END_CASE;

   IF io.exec THEN io.exec := FALSE; 
		IF io.init THEN io.init := FALSE;
			IF delFile THEN yTxB := 'Move'; ELSE yTxB := 'Copy'; END_IF;
			yTxC 	:= CONCAT(yTxB,' ',yTxC);
			rb		:=_NhSysLogMsg(msg:='-> '+yTxC+': '+yTx1+'->'+yTx2);				// log sys message
			rb		:= _Nh_Log_Path(wh:=24, frm:=1, wh2:=2);								// yTx1= log path FileName
			cyc := 0; files := 0; allSize := 0; 	// busy,exec := true;
			IF _NhFopen(fN := yTx1, fH := hLog , mode := 1,log:=FALSE)  THEN 		
   			rb:=_NhSysLogMsg(msg:=yTxC, openFH:=hLog);						   // head
				rb:=_NhSysLogMsg(noTime:=1,noIni:=1,openFH:=hLog,noCRLF:=1,eRowAfter:=1,
										msg :=	srcName + _Nh_CRLF 
												+	dstName + _Nh_CRLF 
				);						
			ELSE
				rb	:= _Nh_Ou_Err(io:=io, msg:=': {'+yTx1+'}', errTyp:=2, ErrID:=1009);
			END_IF;
//   		_NhOulog(ou:=ou,go:=go,ms:='Init-End');
		END_IF;
		IF io.err = FALSE THEN
			IF go = 1 THEN
				go   :=	10;	
				yTx1 := srcName;
				yTx2 := dstName;
			ELSE 
				go   := 12;
				yTx1 := CONCAT(srcName,fi.fileName);
				yTx2 := CONCAT(dstName,fi.fileName);
			END_IF;
			// open src ans dest file
   	   IF _NhFopen(fN := yTx1, fH := hSrc , mode := 0,log:=0) THEN 					// open source file
				io.reqSize	:= fS; io.actSize := 0;
				IF file THEN yTx0	:= yTx1; ELSE yTx0 := fi.fileName; END_IF;
				rb:=_NhSysLogMsg(openFh:=hLog, msg:=yTx0 +' '+ UDINT_TO_STRING(io.reqSize)+'->',noTime:=1,noIni:=1,noCRLF:=1);
//				IF append
				IF _NhFopen(fN := yTx2, fH := hDst , mode := 1,log:=0) = FALSE THEN 				// open dest file
					rb	:= _Nh_Ou_Err(io:=io,msg:=':{'+yTx2+'}', errTyp:=2, ErrID:=1006);
				END_IF;
			ELSE
				rb	:= _Nh_Ou_Err(io:=io, msg:=':{'+yTx1+'}', errTyp:=2, ErrID:=1005);
			END_IF;
		END_IF;		
//		_NhOulog(ou:=ou,go:=go,ms:='Exec-End');
   END_IF;
   cyc := cyc + 1;
	IF io.busy THEN
		io.cycSize 	:= MIN(io.reqSize - io.actSize, _Nh_D12(aSys.mSecMax > aSys.mSecLimit,512,SIZEOF(mObr)));
		fRW 			:= FileRead( hFile := hSrc, adrBuf := PTR_TO_UDINT( ADR(mObr)), size := io.cycSize);
		fRW 			:= FileWrite(hFile := hDst, adrBuf := PTR_TO_UDINT( ADR(mObr)), size := fRW);
		allSize 		:= allSize + fRW; 	// busy,exec := true;
     	io.actSize 	:= io.actSize + fRW; // actual read/write size
		IF io.actSize = io.reqSize THEN
        	io.found:=TRUE; 
      ELSIF fRW <> io.cycSize THEN // the request did not proceed correctly
			rb	:= _Nh_Ou_Err(io:=io, msg:='; fRW: '+UDINT_TO_STRING(fRW)+' cycSize: '+UDINT_TO_STRING(io.cycSize), errTyp := 2, ErrID := 1008);
		END_IF;
//		_NhOulog(ou:=ou,go:=go,ms:='busy-End');
	END_IF;
//   IF io.err THEN 
//		io.done := TRUE; io.found := FALSE;		
//	END_IF;
   IF io.found THEN io.found	:= FALSE;
		files	:= files + 1;
      rb		:= _NhFclose(fH := hSrc);							         // source
      rb		:= _NhFclose(fH := hDst);							         // dest
		yTx0 	:= UDINT_TO_STRING(io.actSize);
		IF file THEN
			io.Done	:= TRUE;                                           // only one file
			IF delFile THEN												       // delete file
				yTx0 := CONCAT(yTx0,' D');
				rb := FileDelete(fileName := yTx2);
			END_IF;
			IF srcName <> dstName THEN
				yTx0 := CONCAT(yTx0,' ->',dstName);
			END_IF;	
		ELSE 
			go 	:= 22;
		END_IF;		
		rb:=_NhSysLogMsg(openFH:=hLog, msg:=yTx0,noTime:=1,noIni:=1);
//		_NhOulog(ou:=ou,go:=go,ms:='Found-End');
	END_IF;
   IF io.done THEN 
      // log sumary
		rb:=_NhSysLogMsg(openFh:=hLog,eRowBefore:=1,noCRLF:=1,
								msg:=	' '+_Nh_CRLF
									+	'Files: '+UINT_TO_STRING(files)		+_Nh_CRLF
									+	'Bytes: '+UDINT_TO_STRING(allSize)	+_Nh_CRLF
									+	'Cycle: '+UINT_TO_STRING(cyc)
								);
      // close all files
     	rb 	 		:= _NhFclose(fH := hSrc);
     	rb 			:= _NhFclose(fH := hDst);
     	rb 			:= _NhFclose(fH := hLog);
		Go 			:= 0;
		io.Busy		:= FALSE;
		IF io.err THEN
//			aSys.Ini	:= IniErr;
		ELSE
//			aSys.Ini	:= IniEnd;
		END_IF;
		IF io.err or delFile = FALSE or file THEN
			;
		ELSIF delDir THEN
			rb := DirDelete(dirName := srcName);
		END_IF;
//		_NhOulog(ou:=ou,go:=go,ms:='Done-End');
   	rb:=_NhSysLogMsg(msg:='-> End');		// log sys message
	END_IF;
END_FUNCTION_BLOCK


VAR_GLOBAL
	fbFileRWa				: _Nh_File_RW;
 	fb_Nh_Create_DIR	     : _Nh_Create_DIR;
 	fb_Nh_Backup		   : _Nh_Backup;
	fb_Nh_Copy_DIR			: _Nh_Copy_DIR;
	fbLine					: _Nh_File_Line;
END_VAR

FUNCTION _NhSysUpd {HIDDEN} : BOOL	
   VAR_INPUT
      file  : USINT;          // + file
   END_VAR
	_NhSysUpd	:= TRUE;
	IF aSys.UpdFile < 253 THEN                                  // 0..234 write. 255 = restore
		aSys.UpdFile 	:= MIN(file, 254 - aSys.UpdFile);
	END_IF;	
END_FUNCTION
